 createHyperrealisticISS(satData) {
 if (DEBUG.enabled) console.log(' Creating ISS with all modules');
 
 // Complete ISS model with ALL modules as of October 2025
 // Real ISS: 109m long Ã— 73m wide Ã— 20m tall, 419,725 kg
 // 16 pressurized modules + truss + solar arrays + radiators
 const iss = new THREE.Group();
 const scale = 0.001; // Increased from 0.0003 for better visibility when zoomed in
 
 // Materials
 const moduleMaterial = new THREE.MeshStandardMaterial({
 color: 0xE8E8E8, // White/silver modules
 roughness: 0.5,
 metalness: 0.7
 });
 
 const russianMaterial = new THREE.MeshStandardMaterial({
 color: 0xD4AF37, // Gold/bronze (Russian modules)
 roughness: 0.4,
 metalness: 0.8
 });
 
 const solarPanelMaterial = new THREE.MeshStandardMaterial({
 color: 0x1a3d5c, // Dark blue solar panels
 roughness: 0.2,
 metalness: 0.9,
 emissive: 0x0a1a2e,
 emissiveIntensity: 0.1
 });
 
 const trussMaterial = new THREE.MeshStandardMaterial({
 color: 0x8B8B8B, // Gray truss
 roughness: 0.6,
 metalness: 0.8
 });
 
 // Helper function to create a module
 const createModule = (length, diameter, material, name) => {
 const geometry = new THREE.CylinderGeometry(scale * diameter, scale * diameter, scale * length, 16);
 const module = new THREE.Mesh(geometry, material);
 module.name = name;
 return module;
 };
 
 // ========== INTEGRATED TRUSS STRUCTURE (ITS) ==========
 // Main backbone - 109m long
 const mainTrussGeometry = new THREE.BoxGeometry(scale * 109, scale * 0.5, scale * 0.5);
 const mainTruss = new THREE.Mesh(mainTrussGeometry, trussMaterial);
 mainTruss.position.set(0, 0, 0);
 mainTruss.name = 'Main Truss';
 iss.add(mainTruss);
 
 // ========== RUSSIAN SEGMENT (launched 1998-2021) ==========
 // 1. Zarya (FGB) - First module, launched Nov 20, 1998
 const zarya = createModule(12.6, 4.1, russianMaterial, 'Zarya (FGB)');
 zarya.rotation.z = Math.PI / 2;
 zarya.position.set(-scale * 20, 0, 0);
 iss.add(zarya);
 
 // 2. Zvezda - Service module, launched Jul 12, 2000
 const zvezda = createModule(13.1, 4.15, russianMaterial, 'Zvezda');
 zvezda.rotation.z = Math.PI / 2;
 zvezda.position.set(-scale * 30, 0, 0);
 iss.add(zvezda);
 
 // 3. Pirs - Docking compartment, launched Sep 14, 2001 (deorbited Jul 2021)
 // Now replaced by Nauka
 
 // 4. Poisk (MRM-2) - Docking module, launched Nov 10, 2009
 const poisk = createModule(4.0, 2.55, russianMaterial, 'Poisk (MRM-2)');
 poisk.position.set(-scale * 30, scale * 5, 0);
 iss.add(poisk);
 
 // 5. Rassvet (MRM-1) - Mini research module, launched May 14, 2010
 const rassvet = createModule(6.0, 2.35, russianMaterial, 'Rassvet (MRM-1)');
 rassvet.position.set(-scale * 20, -scale * 4, 0);
 iss.add(rassvet);
 
 // 6. Nauka - Multipurpose laboratory, launched Jul 21, 2021
 const nauka = createModule(13.0, 4.25, russianMaterial, 'Nauka');
 nauka.rotation.z = Math.PI / 2;
 nauka.position.set(-scale * 38, 0, scale * 2);
 iss.add(nauka);
 
 // 7. Prichal - Docking module, launched Nov 24, 2021
 const prichal = createModule(3.0, 2.0, russianMaterial, 'Prichal');
 prichal.position.set(-scale * 38, -scale * 4, scale * 2);
 iss.add(prichal);
 
 // ========== US SEGMENT ==========
 // 8. Unity (Node 1) - First US module, launched Dec 4, 1998
 const unity = createModule(5.5, 4.57, moduleMaterial, 'Unity (Node 1)');
 unity.rotation.z = Math.PI / 2;
 unity.position.set(-scale * 10, 0, 0);
 iss.add(unity);
 
 // 9. Destiny - US Laboratory, launched Feb 7, 2001
 const destiny = createModule(8.5, 4.27, moduleMaterial, 'Destiny Lab');
 destiny.rotation.z = Math.PI / 2;
 destiny.position.set(-scale * 2, 0, 0);
 iss.add(destiny);
 
 // 10. Quest - Airlock, launched Jul 12, 2001
 const quest = createModule(5.5, 4.0, moduleMaterial, 'Quest Airlock');
 quest.position.set(-scale * 10, 0, -scale * 5);
 iss.add(quest);
 
 // 11. Harmony (Node 2) - Connecting module, launched Oct 23, 2007
 const harmony = createModule(7.2, 4.4, moduleMaterial, 'Harmony (Node 2)');
 harmony.rotation.z = Math.PI / 2;
 harmony.position.set(scale * 8, 0, 0);
 iss.add(harmony);
 
 // 12. Tranquility (Node 3) - Life support, launched Feb 8, 2010
 const tranquility = createModule(6.7, 4.48, moduleMaterial, 'Tranquility (Node 3)');
 tranquility.position.set(scale * 8, 0, -scale * 6);
 iss.add(tranquility);
 
 // 13. Cupola - Observation module, launched Feb 8, 2010
 const cupolaGeometry = new THREE.ConeGeometry(scale * 2.0, scale * 1.5, 8);
 const cupola = new THREE.Mesh(cupolaGeometry, moduleMaterial);
 cupola.position.set(scale * 8, -scale * 5, -scale * 6);
 cupola.name = 'Cupola';
 iss.add(cupola);
 
 // 14. Leonardo (PMM) - Permanent Multipurpose Module, launched Feb 24, 2011
 const leonardo = createModule(6.4, 4.57, moduleMaterial, 'Leonardo (PMM)');
 leonardo.position.set(scale * 8, scale * 4, 0);
 iss.add(leonardo);
 
 // ========== INTERNATIONAL PARTNER MODULES ==========
 // 15. Columbus - European laboratory, launched Feb 7, 2008
 const columbus = createModule(6.9, 4.48, moduleMaterial, 'Columbus (ESA)');
 columbus.rotation.x = Math.PI / 2;
 columbus.position.set(scale * 8, 0, scale * 6);
 iss.add(columbus);
 
 // 16. Kibo (JEM) - Japanese Experiment Module, launched Mar 11 & May 31, 2008
 const kiboMain = createModule(11.2, 4.4, moduleMaterial, 'Kibo PM');
 kiboMain.rotation.x = Math.PI / 2;
 kiboMain.position.set(scale * 12, 0, -scale * 10);
 iss.add(kiboMain);
 
 // Kibo Logistics Module
 const kiboLogistics = createModule(4.2, 4.4, moduleMaterial, 'Kibo ELM');
 kiboLogistics.position.set(scale * 12, scale * 4, -scale * 10);
 iss.add(kiboLogistics);
 
 // Kibo External Facility
 const kiboExternal = new THREE.BoxGeometry(scale * 5, scale * 0.3, scale * 4);
 const kiboExt = new THREE.Mesh(kiboExternal, moduleMaterial);
 kiboExt.position.set(scale * 12, -scale * 3.5, -scale * 10);
 kiboExt.name = 'Kibo EF';
 iss.add(kiboExt);
 
 // ========== COMMERCIAL MODULES ==========
 // 17. BEAM (Bigelow Expandable Activity Module) - launched Apr 8, 2016
 const beam = createModule(4.0, 3.2, moduleMaterial, 'BEAM');
 beam.position.set(scale * 8, -scale * 4, -scale * 6);
 iss.add(beam);
 
 // ========== SOLAR ARRAYS ==========
 // 8 solar arrays (4 pairs) - 73m total wingspan
 const solarArrayGeometry = new THREE.BoxGeometry(scale * 11.58, scale * 0.05, scale * 34.2);
 
 // Port arrays (P4/P6)
 const p6_1 = new THREE.Mesh(solarArrayGeometry, solarPanelMaterial);
 p6_1.position.set(-scale * 40, scale * 8, 0);
 p6_1.name = 'P6 Array 1';
 iss.add(p6_1);
 
 const p6_2 = new THREE.Mesh(solarArrayGeometry, solarPanelMaterial);
 p6_2.position.set(-scale * 40, -scale * 8, 0);
 p6_2.name = 'P6 Array 2';
 iss.add(p6_2);
 
 const p4_1 = new THREE.Mesh(solarArrayGeometry, solarPanelMaterial);
 p4_1.position.set(-scale * 25, scale * 8, 0);
 p4_1.name = 'P4 Array 1';
 iss.add(p4_1);
 
 const p4_2 = new THREE.Mesh(solarArrayGeometry, solarPanelMaterial);
 p4_2.position.set(-scale * 25, -scale * 8, 0);
 p4_2.name = 'P4 Array 2';
 iss.add(p4_2);
 
 // Starboard arrays (S4/S6)
 const s4_1 = new THREE.Mesh(solarArrayGeometry, solarPanelMaterial);
 s4_1.position.set(scale * 25, scale * 8, 0);
 s4_1.name = 'S4 Array 1';
 iss.add(s4_1);
 
 const s4_2 = new THREE.Mesh(solarArrayGeometry, solarPanelMaterial);
 s4_2.position.set(scale * 25, -scale * 8, 0);
 s4_2.name = 'S4 Array 2';
 iss.add(s4_2);
 
 const s6_1 = new THREE.Mesh(solarArrayGeometry, solarPanelMaterial);
 s6_1.position.set(scale * 40, scale * 8, 0);
 s6_1.name = 'S6 Array 1';
 iss.add(s6_1);
 
 const s6_2 = new THREE.Mesh(solarArrayGeometry, solarPanelMaterial);
 s6_2.position.set(scale * 40, -scale * 8, 0);
 s6_2.name = 'S6 Array 2';
 iss.add(s6_2);
 
 // ========== RADIATORS ==========
 // Heat dissipation panels
 const radiatorGeometry = new THREE.BoxGeometry(scale * 15, scale * 0.05, scale * 4.5);
 const radiatorMaterial = new THREE.MeshStandardMaterial({
 color: 0xC0C0C0,
 roughness: 0.3,
 metalness: 0.9
 });
 
 for (let i = 0; i < 6; i++) {
 const radiator = new THREE.Mesh(radiatorGeometry, radiatorMaterial);
 radiator.position.set(-scale * 35 + i * scale * 12, 0, scale * 8);
 radiator.name = `Radiator ${i + 1}`;
 iss.add(radiator);
 }
 
 // ========== ROBOTIC ARMS ==========
 // Canadarm2 - 17.6m long
 const canadarmGeometry = new THREE.CylinderGeometry(scale * 0.35, scale * 0.35, scale * 17.6, 12);
 const canadarm = new THREE.Mesh(canadarmGeometry, trussMaterial);
 canadarm.rotation.z = Math.PI / 4;
 canadarm.position.set(scale * 5, scale * 10, 0);
 canadarm.name = 'Canadarm2';
 iss.add(canadarm);
 
 // Dextre (Special Purpose Dexterous Manipulator)
 const dextreGeometry = new THREE.BoxGeometry(scale * 3.5, scale * 1.5, scale * 1.5);
 const dextre = new THREE.Mesh(dextreGeometry, trussMaterial);
 dextre.position.set(scale * 5, scale * 18, 0);
 dextre.name = 'Dextre';
 iss.add(dextre);
 
 // Japanese robotic arm (on Kibo)
 const jemRMSGeometry = new THREE.CylinderGeometry(scale * 0.25, scale * 0.25, scale * 10, 10);
 const jemRMS = new THREE.Mesh(jemRMSGeometry, trussMaterial);
 jemRMS.rotation.x = Math.PI / 3;
 jemRMS.position.set(scale * 12, scale * 5, -scale * 10);
 jemRMS.name = 'JEM RMS';
 iss.add(jemRMS);
 
 // ========== VISIBILITY AIDS ==========
 // Larger glow for distance visibility
 const glowGeometry = new THREE.SphereGeometry(scale * 10, 16, 16);
 const glowMaterial = new THREE.MeshBasicMaterial({
 color: 0xFFFFFF,
 transparent: true,
 opacity: 0.5
 });
 const glow = new THREE.Mesh(glowGeometry, glowMaterial);
 glow.name = 'Visibility Glow';
 iss.add(glow);
 
 // Larger center marker
 const markerGeometry = new THREE.SphereGeometry(scale * 3, 8, 8);
 const markerMaterial = new THREE.MeshBasicMaterial({
 color: 0xFFD700,
 emissive: 0xFFD700,
 emissiveIntensity: 0.8
 });
 const marker = new THREE.Mesh(markerGeometry, markerMaterial);
 marker.name = 'Center Marker';
 iss.add(marker);
 
 // Enable shadows for all meshes
 iss.traverse((child) => {
 if (child instanceof THREE.Mesh) {
 child.castShadow = true;
 child.receiveShadow = true;
 }
 });
 
 // Count all children for verification
 let moduleCount = 0;
 iss.traverse((child) => {
 if (child instanceof THREE.Mesh) {
 moduleCount++;
 }
 });
 
 console.log(` ISS created with ${moduleCount} mesh components (scale: ${scale})`);
 console.log(' - 17 pressurized modules, 8 solar arrays, 6 radiators, 3 robotic arms');
 
 return iss;
 }

 createSatellites(scene) {
 // Create Earth satellites (ISS and important satellites)
 this.satellites = [];
 
 const satellitesData = [
 { 
 name: 'ISS (International Space Station)', 
 distance: 1.05, // Orbital altitude: 408-410 km above Earth's surface (scaled)
 speed: 15.5, // REAL SPEED: 7.66 km/s (27,576 km/h), 15.5 orbits/day, 92.68 min/orbit
 // Animation: speed * timeSpeed * 0.01 = angle increment
 // At timeSpeed=1: 15.5 * 1 * 0.01 = 0.155 rad/frame = realistic orbital motion
 size: 0.03,
 color: 0xCCCCCC,
 description: ' ISS orbits at 408 km altitude, traveling at 7.66 km/s (27,576 km/h). One orbit takes 92.68 minutes. Continuously inhabited since Nov 2, 2000 (25 years!). Collaboration of NASA, Roscosmos, ESA, JAXA, CSA. Completed 180,000+ orbits as of Oct 2025.',
 funFact: 'ISS is 109m long, 73m wide, masses 419,725 kg. Pressurized volume equals a Boeing 747! Visible to naked eye as brightest "star" after Venus.',
 realSize: '109m Ã— 73m Ã— 20m, 419,725 kg',
 orbitTime: '92.68 minutes',
 modules: '17 pressurized modules: Zarya, Unity, Zvezda, Destiny, Quest, Harmony, Columbus, Kibo (3 parts), Poisk, Tranquility, Cupola, Rassvet, Leonardo, BEAM, Nauka, Prichal. Plus 8 solar arrays, 6 radiators, 3 robotic arms (Canadarm2, Dextre, JEM RMS).'
 },
 { 
 name: 'Hubble Space Telescope', 
 distance: 1.08, // Orbital altitude: ~535 km (varies due to atmospheric drag)
 speed: 15.1, // Orbital velocity: 7.59 km/s (27,300 km/h)
 size: 0.02,
 color: 0x4169E1,
 description: ' Launched April 24, 1990 on Space Shuttle Discovery. Orbits at ~535 km altitude. Made 1.6+ million observations as of Oct 2025. 2.4m primary mirror observes UV, visible, and near-IR. Five servicing missions (1993-2009) upgraded instruments.',
 funFact: 'Can resolve objects 0.05 arcseconds apart - like seeing two fireflies 10,000 km away! Deepest image (eXtreme Deep Field) shows 5,500 galaxies, some 13.2 billion light-years away.',
 realSize: '13.2m long 4.2m diameter, 11,110 kg',
 orbitTime: '95 minutes'
 },
 { 
 name: 'GPS Satellites', 
 distance: 3.5, // Medium Earth Orbit (MEO): 20,180 km altitude (26,560 km from Earth center)
 speed: 2, // Orbital velocity: 3.87 km/s, period: 11h 58min (2 orbits/day)
 size: 0.025,
 color: 0x00FF00,
 description: ' GPS (NAVSTAR) constellation: 31 operational satellites (as of Oct 2025) in 6 orbital planes, 55Â° inclination. Each satellite orbits at 20,180 km altitude. Transmits L-band signals (1.2-1.5 GHz). Rubidium/cesium atomic clocks accurate to 10â»â´ seconds.',
 funFact: 'Need 4 satellites for 3D position fix (trilateration + clock correction). System provides 5-10m accuracy. Military signal (P/Y code) accurate to centimeters!',
 realSize: 'GPS III: 2,161 kg, 7.8m solar span',
 orbitTime: '11h 58min'
 },
 { 
 name: 'James Webb Space Telescope', 
 distance: 250, // At Sun-Earth L2 Lagrange point, 1.5 million km from Earth (scaled)
 speed: 0.01, // Halo orbit around L2, period synced with Earth (1 year)
 size: 0.04,
 color: 0xFFD700,
 description: ' Launched Dec 25, 2021. Reached L2 point Jan 24, 2022. First images released July 12, 2022. Observes infrared (0.6-28.5 Î¼m). 6.5m segmented beryllium mirror (18 hexagons) with 25 mÂ² collecting area - 6x Hubble! Sunshield: 21.2m Ã— 14.2m, 5 layers.',
 funFact: 'Operating at -233C (-388F)! Can detect heat signature of a bumblebee at Moon distance. Discovered earliest galaxies at z=14 (280 million years after Big Bang).',
 realSize: '6.5m mirror, 21.2m 14.2m sunshield, 6,161 kg',
 orbitTime: 'L2 halo orbit: ~6 months period'
 },
 ];

 if (!this.planets.earth) {
 console.warn('Earth not found, cannot create satellites');
 return;
 }

 satellitesData.forEach((satData, index) => {
 let satellite;
 
 // Create hyperrealistic models for ISS, Hubble, and JWST
 if (satData.name.includes('ISS')) {
 satellite = this.createHyperrealisticISS(satData);
 } else if (satData.name.includes('Hubble')) {
 satellite = this.createHyperrealisticHubble(satData);
 } else if (satData.name.includes('James Webb')) {
 satellite = this.createHyperrealisticJWST(satData);
 } else {
 // Simple satellite body for others
 const geometry = new THREE.BoxGeometry(satData.size, satData.size * 0.5, satData.size * 0.3);
 const material = new THREE.MeshStandardMaterial({
 color: satData.color,
 roughness: 0.4,
 metalness: 0.8,
 emissive: satData.color,
 emissiveIntensity: 0.3
 });
 
 satellite = new THREE.Mesh(geometry, material);
 
 // Add solar panels for most satellites
 if (satData.name !== 'Starlink Constellation') {
 const panelGeometry = new THREE.BoxGeometry(satData.size * 2, satData.size * 0.02, satData.size * 0.8);
 const panelMaterial = new THREE.MeshStandardMaterial({
 color: 0x1a3d5c,
 roughness: 0.2,
 metalness: 0.9
 });
 
 const panel1 = new THREE.Mesh(panelGeometry, panelMaterial);
 panel1.position.x = satData.size * 1.2;
 satellite.add(panel1);
 
 const panel2 = new THREE.Mesh(panelGeometry, panelMaterial);
 panel2.position.x = -satData.size * 1.2;
 satellite.add(panel2);
 }
 
 // Add antenna for communication satellites
 if (satData.name.includes('GPS')) {
 const antennaGeometry = new THREE.CylinderGeometry(0.005, 0.005, satData.size * 0.8);
 const antennaMaterial = new THREE.MeshStandardMaterial({
 color: 0x888888,
 roughness: 0.3,
 metalness: 0.9
 });
 const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
 antenna.position.y = satData.size * 0.6;
 satellite.add(antenna);
 }
 }
 
            satellite.userData = {
                name: satData.name,
                type: 'Satellite',
                radius: satData.size,
                actualSize: satData.size, // Use actual size for camera distance calculations
                distance: satData.distance,
                angle: (Math.PI * 2 / satellitesData.length) * index, // Spread them out
                speed: satData.speed,
                description: satData.description,
                funFact: satData.funFact,
                realSize: satData.realSize,
                orbitTime: satData.orbitTime,
                orbitPlanet: 'earth', // Consistent with spacecraft naming
                planet: this.planets.earth,
                isSpacecraft: true, // Mark as spacecraft for camera logic
                inclination: (index * 30) * Math.PI / 180 // Different orbital inclinations
            }; scene.add(satellite);
 this.objects.push(satellite);
 this.satellites.push(satellite);
 });
 }

 createSpacecraft(scene) {
 // Deep space probes and interplanetary missions
 this.spacecraft = [];
 
 const spacecraftData = [
 {
 name: 'Voyager 1',
 distance: 8307, // ~24.3 billion km from Sun as of Oct 2025 (162 AU) - educational scale (162 Ã— 51.28)
 angle: Math.PI * 0.7, // Direction: 35 north of ecliptic plane
 speed: 0.0001, // Traveling at 17 km/s relative to Sun
 size: 0.08,
 color: 0xC0C0C0,
 type: 'probe',
 description: ' Voyager 1 is the farthest human-made object from Earth! Launched Sept 5, 1977, it entered interstellar space on Aug 25, 2012. Currently 24.3 billion km (162 AU) from Sun. It carries the Golden Record with sounds and images of Earth.',
 funFact: 'Voyager 1 travels at 17 km/s (61,200 km/h). Its radio signals take 22.5 hours to reach Earth!',
 realSize: '825.5 kg, 3.7m antenna dish',
 launched: 'September 5, 1977',
 status: 'Active in Interstellar Space (since Aug 2012)'
 },
 {
 name: 'Voyager 2',
 distance: 6923, // ~20.3 billion km from Sun as of Oct 2025 (135 AU) - educational scale (135 Ã— 51.28)
 angle: Math.PI * 1.2, // Direction: Different trajectory than V1
 speed: 0.0001, // Traveling at 15.4 km/s relative to Sun
 size: 0.08,
 color: 0xB0B0B0,
 type: 'probe',
 description: ' Voyager 2 is the only spacecraft to visit all four giant planets! Jupiter (Jul 1979), Saturn (Aug 1981), Uranus (Jan 1986), Neptune (Aug 1989). Entered interstellar space Nov 5, 2018. Now 20.3 billion km (135 AU) from Sun.',
 funFact: 'Voyager 2 discovered 16 moons across the giant planets, Neptune\'s Great Dark Spot, and Triton\'s geysers!',
 realSize: '825.5 kg, 3.7m antenna dish',
 launched: 'August 20, 1977',
 status: 'Active in Interstellar Space (since Nov 2018)'
 },
 {
 name: 'New Horizons',
 distance: 3025, // ~8.9 billion km from Sun as of Oct 2025 (59 AU) - educational scale (59 Ã— 51.28)
 angle: Math.PI * 0.3,
 speed: 0.0002, // Traveling at 14.31 km/s relative to Sun
 size: 0.06,
 color: 0x4169E1,
 type: 'probe',
 description: ' New Horizons gave us the first close-up images of Pluto on July 14, 2015! It revealed water ice mountains up to 3,500m tall, vast nitrogen glaciers, and the famous heart-shaped Tombaugh Regio. Now 59 AU from Sun, exploring Kuiper Belt.',
 funFact: 'New Horizons traveled 9.5 years and 5 billion km to reach Pluto at 58,536 km/h. It carries 1 oz of Clyde Tombaugh\'s ashes!',
 realSize: '478 kg, 0.7 2.1 2.7m (piano-sized)',
 launched: 'January 19, 2006',
 status: 'Active in Kuiper Belt'
 },
 {
 name: 'James Webb Space Telescope',
 distance: 250, // At Sun-Earth L2 Lagrange point, 1.5 million km from Earth (scaled)
 angle: Math.PI * 0.15, // Positioned near Earth's L2 point
 speed: 0.0003, // Halo orbit around L2, period synced with Earth (1 year)
 size: 0.08,
 color: 0xFFD700,
 type: 'observatory',
 description: 'ðŸ”­ James Webb Space Telescope (JWST) is the most powerful space telescope ever built! Launched Dec 25, 2021, it orbits the Sun-Earth L2 point (1.5 million km from Earth). Observes infrared (0.6-28.5 Î¼m) with a 6.5m segmented beryllium mirror - 6Ã— larger than Hubble!',
 funFact: 'JWST operates at -233Â°C (-388Â°F) behind a tennis court-sized sunshield! It can see the first galaxies formed just 280 million years after the Big Bang.',
 realSize: '6.5m mirror, 21.2m Ã— 14.2m sunshield, 6,161 kg',
 launched: 'December 25, 2021',
 status: 'Active at L2 Point'
 },
 {
 name: 'Juno (Jupiter)',
 orbitPlanet: 'jupiter',
 distance: 11.5, // Highly elliptical polar orbit: 4,200 km to 8.1 million km from Jupiter's cloud tops
 angle: 0,
 speed: 3.0, // Orbital period: 53.5 days
 size: 0.05,
 color: 0xFFD700,
 type: 'orbiter',
 description: ' Juno entered Jupiter orbit July 4, 2016. Studies composition, gravity field, magnetic field, and polar auroras. Discovered Jupiter\'s core is larger and "fuzzy", massive polar cyclones, and atmospheric ammonia distribution. Extended mission until Sept 2025.',
 funFact: 'First solar-powered spacecraft at Jupiter! Three 9m solar panels generate 500W. Carries three LEGO figurines: Galileo, Jupiter, and Juno!',
 realSize: '3,625 kg, 20m solar panel span',
 launched: 'August 5, 2011',
 status: 'Active in Jupiter Orbit (63+ orbits)'
 },
 {
 name: 'Cassini-Huygens Legacy (Saturn)',
 orbitPlanet: 'saturn',
 distance: 9.6, // Orbited Saturn 294 times before Grand Finale
 angle: 0,
 speed: 2.5,
 size: 0.06,
 color: 0xDAA520,
 type: 'memorial',
 description: ' Cassini orbited Saturn June 30, 2004 - Sept 15, 2017 (13 years). Discovered liquid methane/ethane lakes on Titan, water geysers on Enceladus, new rings, 7 new moons. Huygens probe landed on Titan Jan 14, 2005. Ended with atmospheric entry "Grand Finale".',
 funFact: 'Discovered Enceladus\' subsurface ocean! Water geysers shoot 250kg/s into space. Cassini flew through plumes, detected H2, organics - ingredients for life!',
 realSize: '5,600 kg, 6.8m tall, 4m wide',
 launched: 'October 15, 1997',
 status: 'Mission Ended Sept 15, 2017 (Memorial)'
 },
 {
 name: 'Pioneer 10',
 distance: 6820, // ~19.9 billion km from Sun (133 AU) - educational scale (133 Ã— 51.28)
 angle: Math.PI * 0.5, // Direction: toward Aldebaran in Taurus
 speed: 0.00009, // Traveling at 12.2 km/s relative to Sun
 size: 0.07,
 color: 0xA0A0A0,
 type: 'memorial',
 description: ' Pioneer 10 was the first spacecraft to travel through the asteroid belt and first to visit Jupiter (Dec 3, 1973)! Launched March 2, 1972, it carried the famous Pioneer plaque showing humans and Earth\'s location. Last contact: Jan 23, 2003 at 12.2 billion km.',
 funFact: 'Pioneer 10 carries a gold plaque designed by Carl Sagan showing a man, woman, and Earth\'s location - a message to any aliens who might find it!',
 realSize: '258 kg, 2.74m antenna dish',
 launched: 'March 2, 1972',
 status: 'Silent since Jan 2003 (Memorial)'
 },
 {
 name: 'Pioneer 11',
 distance: 5436, // ~15.9 billion km from Sun (106 AU) - educational scale (106 Ã— 51.28)
 angle: Math.PI * 1.4, // Direction: toward constellation Aquila
 speed: 0.00008, // Traveling at 11.4 km/s relative to Sun
 size: 0.07,
 color: 0x909090,
 type: 'memorial',
 description: ' Pioneer 11 was the first spacecraft to visit Saturn (Sept 1, 1979)! Also flew by Jupiter (Dec 2, 1974). Launched April 5, 1973, it discovered Saturn\'s F ring and a new moon. Also carries the Pioneer plaque. Last contact: Nov 24, 1995 at 6.5 billion km.',
 funFact: 'Pioneer 11 used Jupiter\'s gravity to slingshot to Saturn - the first gravity-assist maneuver to another planet!',
 realSize: '259 kg, 2.74m antenna dish',
 launched: 'April 5, 1973',
 status: 'Silent since Nov 1995 (Memorial)'
 }
 ];

 spacecraftData.forEach(craft => {
 // Create HYPER-REALISTIC spacecraft with detailed geometry
 const spacecraftGroup = new THREE.Group();
 
 // Main body - octagonal/box shape for probes
 if (craft.type === 'probe' || craft.type === 'orbiter') {
 // Central bus/body - box shape
 const bodyGeometry = new THREE.BoxGeometry(craft.size * 0.8, craft.size * 0.6, craft.size * 0.8);
 const bodyMaterial = new THREE.MeshStandardMaterial({
 color: craft.color,
 roughness: 0.4,
 metalness: 0.7,
 emissive: craft.color,
 emissiveIntensity: 0.1
 });
 const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
 spacecraftGroup.add(body);
 
 // High-gain antenna dish - realistic parabolic shape
 const dishGeometry = new THREE.CylinderGeometry(craft.size * 1.5, craft.size * 1.8, craft.size * 0.15, 24);
 const dishMaterial = new THREE.MeshStandardMaterial({
 color: 0xF0F0F0,
 roughness: 0.2,
 metalness: 0.95,
 envMapIntensity: 1.5
 });
 const dish = new THREE.Mesh(dishGeometry, dishMaterial);
 dish.rotation.x = Math.PI / 2;
 dish.position.set(0, craft.size * 0.4, 0);
 spacecraftGroup.add(dish);
 
 // Dish support struts - tripod
 for (let i = 0; i < 3; i++) {
 const angle = (i / 3) * Math.PI * 2;
 const strutGeometry = new THREE.CylinderGeometry(craft.size * 0.02, craft.size * 0.02, craft.size * 0.5);
 const strutMaterial = new THREE.MeshStandardMaterial({
 color: 0x404040,
 roughness: 0.7,
 metalness: 0.9
 });
 const strut = new THREE.Mesh(strutGeometry, strutMaterial);
 strut.position.set(
 Math.cos(angle) * craft.size * 0.5,
 craft.size * 0.15,
 Math.sin(angle) * craft.size * 0.5
 );
 strut.rotation.x = Math.PI / 2;
 strut.rotation.z = angle;
 spacecraftGroup.add(strut);
 }
 
 // RTG (Radioisotope Thermoelectric Generator) boom - characteristic long boom
 const rtgBoomGeometry = new THREE.CylinderGeometry(craft.size * 0.04, craft.size * 0.04, craft.size * 2.5);
 const rtgBoomMaterial = new THREE.MeshStandardMaterial({
 color: 0x606060,
 roughness: 0.6,
 metalness: 0.85
 });
 const rtgBoom = new THREE.Mesh(rtgBoomGeometry, rtgBoomMaterial);
 rtgBoom.position.set(craft.size * 1.2, 0, 0);
 rtgBoom.rotation.z = Math.PI / 2;
 spacecraftGroup.add(rtgBoom);
 
 // RTG unit at end of boom - cylindrical
 const rtgGeometry = new THREE.CylinderGeometry(craft.size * 0.15, craft.size * 0.15, craft.size * 0.4, 8);
 const rtgMaterial = new THREE.MeshStandardMaterial({
 color: 0x2A2A2A,
 roughness: 0.5,
 metalness: 0.8,
 emissive: 0xFF4400,
 emissiveIntensity: 0.3 // RTGs glow slightly from heat
 });
 const rtg = new THREE.Mesh(rtgGeometry, rtgMaterial);
 rtg.position.set(craft.size * 2.4, 0, 0);
 rtg.rotation.z = Math.PI / 2;
 spacecraftGroup.add(rtg);
 
 // Science instruments boom on opposite side
 const scienceBoomGeometry = new THREE.CylinderGeometry(craft.size * 0.03, craft.size * 0.03, craft.size * 1.8);
 const scienceBoomMaterial = new THREE.MeshStandardMaterial({
 color: 0x505050,
 roughness: 0.7,
 metalness: 0.8
 });
 const scienceBoom = new THREE.Mesh(scienceBoomGeometry, scienceBoomMaterial);
 scienceBoom.position.set(-craft.size * 0.9, 0, 0);
 scienceBoom.rotation.z = Math.PI / 2;
 spacecraftGroup.add(scienceBoom);
 
 // Instruments cluster - small boxes
 for (let i = 0; i < 2; i++) {
 const instGeometry = new THREE.BoxGeometry(craft.size * 0.12, craft.size * 0.12, craft.size * 0.08);
 const instMaterial = new THREE.MeshStandardMaterial({
 color: 0x808080,
 roughness: 0.5,
 metalness: 0.7
 });
 const inst = new THREE.Mesh(instGeometry, instMaterial);
 inst.position.set(-craft.size * 1.8, i * craft.size * 0.15 - craft.size * 0.07, 0);
 spacecraftGroup.add(inst);
 }
 
 } else {
 // Memorial/generic - still make it detailed
 const bodyGeometry = new THREE.OctahedronGeometry(craft.size * 0.7);
 const bodyMaterial = new THREE.MeshStandardMaterial({
 color: craft.color,
 roughness: 0.4,
 metalness: 0.8,
 emissive: craft.color,
 emissiveIntensity: 0.2
 });
 const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
 spacecraftGroup.add(body);
 
 // Add some detail
 const panelGeometry = new THREE.BoxGeometry(craft.size * 0.3, craft.size * 0.05, craft.size * 1.0);
 const panelMaterial = new THREE.MeshStandardMaterial({
 color: 0x1A1A2E,
 roughness: 0.3,
 metalness: 0.9
 });
 const panel = new THREE.Mesh(panelGeometry, panelMaterial);
 panel.position.set(craft.size * 0.5, 0, 0);
 spacecraftGroup.add(panel);
 }
 
 // Add subtle visibility glow - proportional to actual size
 const glowSize = craft.size * 2.5; // Subtle glow for visibility
 const glowGeometry = new THREE.SphereGeometry(glowSize, 16, 16);
 const glowMaterial = new THREE.MeshBasicMaterial({
 color: craft.color,
 transparent: true,
 opacity: 0.3,
 blending: THREE.AdditiveBlending,
 depthWrite: false
 });
 const glow = new THREE.Mesh(glowGeometry, glowMaterial);
 spacecraftGroup.add(glow);
 
 // Add small bright navigation marker for distant spacecraft
 if (craft.distance > 200) {
 const markerGeometry = new THREE.SphereGeometry(craft.size * 0.5, 8, 8);
 const markerMaterial = new THREE.MeshBasicMaterial({
 color: 0xFFFFFF,
 transparent: true,
 opacity: 0.95,
 blending: THREE.AdditiveBlending
 });
 const marker = new THREE.Mesh(markerGeometry, markerMaterial);
 spacecraftGroup.add(marker);
 }
 
 spacecraftGroup.userData = {
 name: craft.name,
 type: craft.type,
 description: craft.description,
 funFact: craft.funFact,
 realSize: craft.realSize,
 launched: craft.launched,
 status: craft.status,
 distance: craft.distance,
 angle: craft.angle,
 speed: craft.speed,
 orbitPlanet: craft.orbitPlanet,
 isMoon: craft.isMoon || false,
 isSpacecraft: true,
 actualSize: craft.size,
 radius: craft.size
 };
 
 if (DEBUG.enabled) console.log(` ${craft.name} created`);
 
 // Position spacecraft
 if (craft.orbitPlanet) {
 // Orbiter around planet
 const planet = this.planets[craft.orbitPlanet];
 if (planet) {
 spacecraftGroup.position.x = craft.distance * Math.cos(craft.angle);
 spacecraftGroup.position.z = craft.distance * Math.sin(craft.angle);
 planet.add(spacecraftGroup);
 }
 } else {
 // Deep space probe - position in solar system
 spacecraftGroup.position.x = craft.distance * Math.cos(craft.angle);
 spacecraftGroup.position.z = craft.distance * Math.sin(craft.angle);
 scene.add(spacecraftGroup);
 }
 
 this.objects.push(spacecraftGroup);
 this.spacecraft.push(spacecraftGroup);
 });
 
 console.log(` Created ${this.spacecraft.length} spacecraft and probes!`);
 }

 update(deltaTime, timeSpeed, camera, controls) {
 // Safety check for deltaTime
 if (!deltaTime || isNaN(deltaTime) || deltaTime <= 0 || deltaTime > 1) {
 console.warn(' Invalid deltaTime:', deltaTime, '- skipping frame');
 return;
 }
 
 // Update camera tracking for focused objects (before other updates)
 this.updateCameraTracking(camera, controls);
 
 // Get pause mode from sceneManager
 const app = window.app || {};
 const sceneManager = app.sceneManager || {};
 const pauseMode = sceneManager.pauseMode || 'none';
 
 // Calculate effective time speeds based on pause mode
 let orbitalSpeed = timeSpeed;
 let rotationSpeed = timeSpeed;
 let moonSpeed = timeSpeed;
 
 if (pauseMode === 'all') {
 // Pause everything
 orbitalSpeed = 0;
 rotationSpeed = 0;
 moonSpeed = 0;
 } else if (pauseMode === 'orbital') {
 // Pause only solar orbits, keep rotations and moon orbits
 orbitalSpeed = 0;
 rotationSpeed = timeSpeed;
 moonSpeed = timeSpeed;
 }
 // else 'none' - everything moves normally
 
 // Update all planets
 Object.values(this.planets).forEach(planet => {
 if (planet && planet.userData) {
 // Calculate angle increment based on speed
 const angleIncrement = planet.userData.speed * orbitalSpeed * deltaTime;
 
 // Safety check for angle increment
 if (isNaN(angleIncrement) || !isFinite(angleIncrement)) {
 console.error(' Invalid angleIncrement for', planet.userData.name, ':', angleIncrement);
 return;
 }
 
 // Solar orbit (affected by orbital pause)
 planet.userData.angle += angleIncrement;
 
 // Safety check for angle
 if (isNaN(planet.userData.angle) || !isFinite(planet.userData.angle)) {
 console.error(' Invalid angle for', planet.userData.name, '- resetting to 0');
 planet.userData.angle = 0;
 }
 
 planet.position.x = planet.userData.distance * Math.cos(planet.userData.angle);
 planet.position.z = planet.userData.distance * Math.sin(planet.userData.angle);
 
 // REALISTIC PLANET ROTATION based on real astronomical data
 if (planet.userData.realRotationPeriod && rotationSpeed > 0) {
 // Calculate elapsed real time in hours
 const elapsedMs = Date.now() - this.realTimeStart;
 const elapsedHours = (elapsedMs / 1000 / 3600) * this.timeAcceleration;
 
 // Calculate rotation angle based on real rotation period
 const rotationsComplete = elapsedHours / planet.userData.realRotationPeriod;
 let rotationAngle = (rotationsComplete * Math.PI * 2) + planet.userData.rotationPhase;
 
 // Reverse rotation for retrograde planets (Venus, Uranus)
 if (planet.userData.retrograde) {
 rotationAngle = -rotationAngle;
 }
 
 // Apply rotation
 planet.rotation.y = rotationAngle;
 
 // Apply axial tilt (already set during creation, but ensure it stays)
 planet.rotation.z = (planet.userData.axialTilt || 0) * Math.PI / 180;
 }
 
 // Rotate clouds slightly faster than planet for Earth
 if (planet.userData.clouds && rotationSpeed > 0) {
 planet.userData.clouds.rotation.y = planet.rotation.y * 1.05; // 5% faster
 }

 // Update moons - orbit around their parent planet
 if (planet.userData.moons && planet.userData.moons.length > 0) {
 planet.userData.moons.forEach(moon => {
 if (moon.userData) {
 // Calculate moon angle increment
 const moonAngleIncrement = moon.userData.speed * moonSpeed * deltaTime;
 
 // Moons orbit their planet
 moon.userData.angle += moonAngleIncrement;
 
 // IMPORTANT: Since moon is a child of planet (planet.add(moon)),
 // these positions are RELATIVE to the planet's position, not world coordinates!
 // This keeps the moon orbiting around its parent planet correctly.
 moon.position.x = moon.userData.distance * Math.cos(moon.userData.angle);
 moon.position.z = moon.userData.distance * Math.sin(moon.userData.angle);
 moon.position.y = 0; // Keep moons in planet's equatorial plane
 
 // REALISTIC MOON ROTATION based on real astronomical data
 if (moon.userData.realRotationPeriod && rotationSpeed > 0) {
 // Calculate elapsed real time in hours
 const elapsedMs = Date.now() - this.realTimeStart;
 const elapsedHours = (elapsedMs / 1000 / 3600) * this.timeAcceleration;
 
 // Calculate rotation angle based on real rotation period
 const rotationsComplete = elapsedHours / moon.userData.realRotationPeriod;
 let rotationAngle = (rotationsComplete * Math.PI * 2) + moon.userData.rotationPhase;
 
 // Reverse rotation for retrograde moons
 if (moon.userData.retrograde) {
 rotationAngle = -rotationAngle;
 }
 
 // Apply rotation
 moon.rotation.y = rotationAngle;
 
 // Apply axial tilt
 moon.rotation.z = (moon.userData.axialTilt || 0) * Math.PI / 180;
 }
 
 // Debug: Log moon position occasionally (Moon and Io)
 if (DEBUG.enabled && Math.random() < 0.001) {
 if (moon.userData.name.includes('Moon') || moon.userData.name.includes('Io')) {
 const worldPos = new THREE.Vector3();
 moon.getWorldPosition(worldPos);
 console.log(` ${moon.userData.name} orbiting ${planet.userData.name}: angle=${moon.userData.angle.toFixed(2)}, local=(${moon.position.x.toFixed(1)}, ${moon.position.y.toFixed(1)}, ${moon.position.z.toFixed(1)}), world=(${worldPos.x.toFixed(1)}, ${worldPos.y.toFixed(1)}, ${worldPos.z.toFixed(1)}), planet at=(${planet.position.x.toFixed(1)}, ${planet.position.y.toFixed(1)}, ${planet.position.z.toFixed(1)})`);
 }
 }
 }
 });
 }
 }
 });
 
 // Keep camera focused on selected object if it's moving
 if (this.focusedObject && camera && controls) {
 const targetPosition = new THREE.Vector3();
 this.focusedObject.getWorldPosition(targetPosition);
 
 // Calculate the offset from target to camera
 const cameraOffset = new THREE.Vector3().subVectors(camera.position, controls.target);
 
 // Update both target and camera position to maintain relative view
 controls.target.copy(targetPosition);
 camera.position.copy(targetPosition).add(cameraOffset);
 
 controls.update();
 }

 // Rotate asteroid and Kuiper belts slowly
 const effectiveTimeSpeed = timeSpeed;
 if (this.asteroidBelt) {
 const rotationIncrement = 0.0001 * effectiveTimeSpeed;
 if (!isNaN(rotationIncrement) && isFinite(rotationIncrement)) {
 this.asteroidBelt.rotation.y += rotationIncrement;
 }
 }
 if (this.kuiperBelt) {
 const rotationIncrement = 0.00005 * effectiveTimeSpeed;
 if (!isNaN(rotationIncrement) && isFinite(rotationIncrement)) {
 this.kuiperBelt.rotation.y += rotationIncrement;
 }
 }

 // Rotate sun and animate surface activity
 if (this.sun) {
 const rotationIncrement = 0.001 * effectiveTimeSpeed;
 if (!isNaN(rotationIncrement) && isFinite(rotationIncrement)) {
 this.sun.rotation.y += rotationIncrement;
 }
 
 // Animate solar flares (optimized - update every 2 frames)
 if (this.sun.userData.flares && (this._sunFlareFrame || 0) % 2 === 0) {
 const time = Date.now() * 0.001;
 const sizes = this.sun.userData.flares.geometry.attributes.size.array;
 const len = sizes.length;
 
 // Pre-calculate random values (less Math.random() calls)
 for (let i = 0; i < len; i++) {
 sizes[i] = 1 + Math.sin(time + i * 0.5) * 1.5 + (i % 3) * 0.2;
 }
 this.sun.userData.flares.geometry.attributes.size.needsUpdate = true;
 }
 this._sunFlareFrame = (this._sunFlareFrame || 0) + 1;
 }

 // Twinkle stars slightly (optimized - only every 5 frames)
 if (this.starfield && this._starTwinkleFrame % 5 === 0 && Math.random() < 0.3) {
 const sizes = this.starfield.geometry.attributes.size.array;
 // Reduce updates to 30 stars instead of 50
 for (let i = 0; i < 30; i++) {
 const idx = Math.floor(Math.random() * sizes.length);
 sizes[idx] = 1 + Math.random() * 2;
 }
 this.starfield.geometry.attributes.size.needsUpdate = true;
 }
 this._starTwinkleFrame = (this._starTwinkleFrame || 0) + 1;
 
 // Update comets with elliptical orbits (optimized)
 if (this.comets) {
 this.comets.forEach(comet => {
 const userData = comet.userData;
 const angleIncrement = userData.speed * effectiveTimeSpeed;
 if (!isNaN(angleIncrement) && isFinite(angleIncrement)) {
 userData.angle += angleIncrement;
 }
 
 // Elliptical orbit calculation
 const e = userData.eccentricity;
 const a = userData.distance;
 const angle = userData.angle;
 
 // Pre-calculate trig values (avoid redundant calculations)
 const cosAngle = Math.cos(angle);
 const sinAngle = Math.sin(angle);
 
 // Simplified elliptical orbit
 const r = a * (1 - e * e) / (1 + e * cosAngle);
 comet.position.x = r * cosAngle;
 comet.position.z = r * sinAngle;
 comet.position.y = Math.sin(angle * 0.5) * 20;
 
 // Show/hide comet tails based on toggle
 if (userData.dustTail) {
 userData.dustTail.visible = this.cometTailsVisible;
 }
 if (userData.ionTail) {
 userData.ionTail.visible = this.cometTailsVisible;
 }
 
 // Only update tails if they're visible
 if (!this.cometTailsVisible) {
 userData.frameCount = (userData.frameCount || 0) + 1;
 return;
 }
 
 // Cache direction vectors (reuse objects to avoid GC)
 if (!userData._sunDir) userData._sunDir = new THREE.Vector3();
 if (!userData._velDir) userData._velDir = new THREE.Vector3();
 
 userData._sunDir.set(-comet.position.x, -comet.position.y, -comet.position.z).normalize();
 userData._velDir.set(Math.cos(angle + Math.PI/2), 0, Math.sin(angle + Math.PI/2)).normalize();
 
 // Update dust tail (only every 3 frames for performance)
 if (userData.dustTail && userData.frameCount % 3 === 0) {
 const dustPositions = userData.dustTail.geometry.attributes.position.array;
 const dustSizes = userData.dustTail.geometry.attributes.size.array;
 
 const curveFactor = 0.3;
 for (let i = 0; i < 200; i++) {
 const t = i / 200;
 const length = 80 * t;
 
 // Curve effect - pre-calculated
 const dirX = userData._sunDir.x + userData._velDir.x * curveFactor * t;
 const dirY = userData._sunDir.y + userData._velDir.y * curveFactor * t;
 const dirZ = userData._sunDir.z + userData._velDir.z * curveFactor * t;
 const normFactor = 1 / Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
 
 // Add spread
 const spread = (Math.random() - 0.5) * 15 * t;
 const spreadPerpendicular = (Math.random() - 0.5) * 8 * t;
 
 dustPositions[i * 3] = dirX * normFactor * length + spread;
 dustPositions[i * 3 + 1] = dirY * normFactor * length + spreadPerpendicular;
 dustPositions[i * 3 + 2] = dirZ * normFactor * length + spread;
 
 // Vary size (less random() calls)
 dustSizes[i] = 3 * (1 - t * 0.7) * (0.9 + (i % 5) * 0.05);
 }
 userData.dustTail.geometry.attributes.position.needsUpdate = true;
 userData.dustTail.geometry.attributes.size.needsUpdate = true;
 }
 
 // Update ion tail (only every 2 frames for performance)
 if (userData.ionTail && userData.frameCount % 2 === 0) {
 const ionPositions = userData.ionTail.geometry.attributes.position.array;
 const sunDirX = userData._sunDir.x;
 const sunDirY = userData._sunDir.y;
 const sunDirZ = userData._sunDir.z;
 
 for (let i = 0; i < 150; i++) {
 const t = i / 150;
 const length = 120 * t;
 const spread = (Math.random() - 0.5) * 3 * t;
 
 ionPositions[i * 3] = sunDirX * length + spread;
 ionPositions[i * 3 + 1] = sunDirY * length + spread;
 ionPositions[i * 3 + 2] = sunDirZ * length + spread;
 }
 userData.ionTail.geometry.attributes.position.needsUpdate = true;
 }
 
 userData.frameCount = (userData.frameCount || 0) + 1;
 });
 }
 
 // Update satellites orbiting Earth
 if (this.satellites) {
 this.satellites.forEach(satellite => {
 const userData = satellite.userData;
 if (userData.planet) {
 const angleIncrement = userData.speed * effectiveTimeSpeed * 0.01; // Scale down for realistic orbit times
 if (!isNaN(angleIncrement) && isFinite(angleIncrement)) {
 userData.angle += angleIncrement;
 }
 
 // Get Earth's world position
 const earthPosition = new THREE.Vector3();
 userData.planet.getWorldPosition(earthPosition);
 
 // Calculate satellite position relative to Earth with inclination
 const cosAngle = Math.cos(userData.angle);
 const sinAngle = Math.sin(userData.angle);
 const cosIncl = Math.cos(userData.inclination);
 const sinIncl = Math.sin(userData.inclination);
 
 satellite.position.x = earthPosition.x + userData.distance * cosAngle;
 satellite.position.y = earthPosition.y + userData.distance * sinAngle * sinIncl;
 satellite.position.z = earthPosition.z + userData.distance * sinAngle * cosIncl;
 
 // Calculate and store orbital velocity vector for camera co-rotation
 // Tangent to circular orbit (perpendicular to radial direction)
 const velocityX = -userData.distance * sinAngle;
 const velocityY = userData.distance * cosAngle * sinIncl;
 const velocityZ = userData.distance * cosAngle * cosIncl;
 
 if (!userData.orbitalVelocity) {
 userData.orbitalVelocity = new THREE.Vector3();
 }
 userData.orbitalVelocity.set(velocityX, velocityY, velocityZ).normalize();
 
 // Debug: Log satellite positions (especially ISS)
 if (Math.random() < 0.001) {
 if (userData.name.includes('ISS')) {
 console.log(` ISS: Earth at (${earthPosition.x.toFixed(1)}, ${earthPosition.y.toFixed(1)}, ${earthPosition.z.toFixed(1)}), ISS at (${satellite.position.x.toFixed(1)}, ${satellite.position.y.toFixed(1)}, ${satellite.position.z.toFixed(1)}), distance=${userData.distance}, visible=${satellite.visible}, children=${satellite.children.length}`);
 }
 }
 
 // ISS: Maintain stable orientation (no rotation)
 // All satellites should be tidally locked to Earth (always facing Earth)
 // This is realistic - ISS maintains nadir-pointing orientation
 satellite.lookAt(earthPosition);
 }
 });
 }
 
 // Update spacecraft (Voyagers, probes, orbiters)
 if (this.spacecraft) {
 // Get numeric speed multiplier
 const effectiveTimeSpeed = timeSpeed;
 
 this.spacecraft.forEach(craft => {
 const userData = craft.userData;
 
 // Deep space probes keep moving away
 if (!userData.orbitPlanet && userData.speed) {
 const angleIncrement = userData.speed * effectiveTimeSpeed * 0.001;
 if (!isNaN(angleIncrement) && isFinite(angleIncrement)) {
 userData.angle += angleIncrement;
 craft.position.x = userData.distance * Math.cos(userData.angle);
 craft.position.z = userData.distance * Math.sin(userData.angle);
 }
 }
 
 // Orbiters around planets (Juno, Cassini legacy, etc)
 if (userData.orbitPlanet && userData.speed && userData.type === 'orbiter') {
 const angleIncrement = userData.speed * effectiveTimeSpeed * 0.01;
 if (!isNaN(angleIncrement) && isFinite(angleIncrement)) {
 userData.angle += angleIncrement;
 const radius = userData.distance;
 craft.position.x = radius * Math.cos(userData.angle);
 craft.position.z = radius * Math.sin(userData.angle);
 craft.position.y = Math.sin(userData.angle * 2) * radius * 0.1; // Inclined orbit
 }
 }
 
 // Rotate spacecraft slowly
 if (userData.type === 'probe' || userData.type === 'orbiter') {
 const rotationIncrement = 0.002 * effectiveTimeSpeed;
 if (!isNaN(rotationIncrement) && isFinite(rotationIncrement)) {
 craft.rotation.y += rotationIncrement;
 }
 }
 });
 }
 
 // Rotate nebulae slowly (optimized - pre-calculate time)
 if (this.nebulae) {
 const effectiveTimeSpeed = timeSpeed;
 const time = Date.now() * 0.0005;
 const scale = 1 + Math.sin(time) * 0.05;
 
 this.nebulae.forEach(nebula => {
 const rotationIncrement = 0.0001 * effectiveTimeSpeed;
 if (!isNaN(rotationIncrement) && isFinite(rotationIncrement)) {
 nebula.rotation.y += rotationIncrement;
 }
 // Pulsing effect (shared calculation)
 nebula.scale.setScalar(scale);
 });
 }
 
 // Rotate galaxies
 if (this.galaxies) {
 const effectiveTimeSpeed = timeSpeed;
 this.galaxies.forEach(galaxy => {
 const rotationIncrement = 0.0002 * effectiveTimeSpeed;
 if (!isNaN(rotationIncrement) && isFinite(rotationIncrement)) {
 galaxy.rotation.y += rotationIncrement;
 }
 });
 }
 
 // Twinkle distant stars
 if (this.distantStars) {
 this.distantStars.forEach(star => {
 if (Math.random() < 0.01) {
 const scale = 0.9 + Math.random() * 0.2;
 star.scale.setScalar(scale);
 }
 });
 }
 }

 cleanup(scene) {
 // Dispose materials only (geometries are cached and reused)
 this.objects.forEach(obj => {
 if (obj.material) {
 if (Array.isArray(obj.material)) {
 obj.material.forEach(mat => mat.dispose());
 } else {
 obj.material.dispose();
 }
 }
 scene.remove(obj);
 });
 
 // Clean up starfield
 if (this.starfield) {
 if (this.starfield.geometry) this.starfield.geometry.dispose();
 if (this.starfield.material) this.starfield.material.dispose();
 scene.remove(this.starfield);
 }

 // Clean up orbital paths
 this.orbits.forEach(orbit => {
 if (orbit.geometry) orbit.geometry.dispose();
 if (orbit.material) orbit.material.dispose();
 scene.remove(orbit);
 });

 // Remove sun light
 const sunLight = scene.getObjectByName('sunLight');
 if (sunLight) scene.remove(sunLight);

 // Dispose cached geometries when fully cleaning up
 this.geometryCache.forEach(geo => geo.dispose());
 this.geometryCache.clear();

 this.objects = [];
 this.planets = {};
 this.moons = {};
 this.sun = null;
 this.starfield = null;
 this.asteroidBelt = null;
 this.kuiperBelt = null;
 this.orbits = [];
 }

 getSelectableObjects() {
 return this.objects;
 }
 
 toggleOrbits(visible) {
 this.orbitsVisible = visible;
 this.orbits.forEach(orbit => {
 orbit.visible = visible;
 });
 console.log(` Orbit paths ${visible ? 'shown' : 'hidden'}`);
 }
 
 toggleConstellations(visible) {
 this.constellationsVisible = visible;
 this.constellations.forEach(constellation => {
 constellation.visible = visible;
 });
 console.log(` Constellations ${visible ? 'shown' : 'hidden'}`);
 }
 
 updateScale() {
 // Update all planetary positions based on scale mode
 const scaleFactors = this.realisticScale ? {
 // Realistic scale (AU converted to scene units, 1 AU = 150 units)
 mercury: 57.9,
 venus: 108.2,
 earth: 150,
 mars: 227.9,
 jupiter: 778.6,
 saturn: 1433.5,
 uranus: 2872.5,
 neptune: 4495.1,
 pluto: 5906.4
 } : {
 // Educational scale - proportionally compressed but maintaining relative distances
 // Real AU ratios (Mercury = 1x): Venus 1.85x, Earth 2.56x, Mars 3.90x, 
 // Jupiter 13.3x, Saturn 24.5x, Uranus 49.2x, Neptune 77.1x, Pluto 101.2x
 // 
 // Scaled to fit with constraints:
 // - Asteroid belt: 100-150 (125 Â± 25) - between Mars and Jupiter
 // - Kuiper belt: 1600-2400 (2000 Â± 400) - beyond Neptune, includes Pluto
 // - Mars + moons (max +2.5) must be < 100
 // - Jupiter + moons (max +23) must be > 150
 // - All proportions maintained relative to real astronomical distances
 mercury: 20,   // Base unit (0.39 AU)
 venus: 37,     // 1.85x Mercury (0.72 AU) - was 30
 earth: 51,     // 2.56x Mercury (1.0 AU) - was 45
 mars: 78,      // 3.90x Mercury (1.52 AU) - was 55, Deimos at +2.5 = 80.5 (clears belt at 100)
 jupiter: 266,  // 13.3x Mercury (5.20 AU) - was 120, Callisto at +23 = 289 (clears belt at 150)
 saturn: 490,   // 24.5x Mercury (9.54 AU) - was 180, Rhea at +12 = 502
 uranus: 984,   // 49.2x Mercury (19.19 AU) - was 235, Titania at +5 = 989
 neptune: 1542, // 77.1x Mercury (30.07 AU) - was 270, Triton at +5 = 1547 (clears Kuiper at 700)
 pluto: 2024    // 101.2x Mercury (39.48 AU) - was 340, inside Kuiper belt as it should be
 };
 
 // Update planet distances
 Object.entries(this.planets).forEach(([name, planet]) => {
 if (planet && planet.userData) {
 const newDistance = scaleFactors[name];
 if (newDistance) {
 planet.userData.distance = newDistance;
 }
 }
 });
 
 // Recreate orbital paths with new distances
 this.updateOrbitalPaths();
 
 // Update asteroid belt and Kuiper belt positions
 this.updateBelts();
 
 // Update spacecraft positions
 this.updateSpacecraftPositions();
 
 // Update comet positions
 this.updateCometPositions();
 
 // Update nebulae and galaxies positions
 this.updateDeepSpaceObjects();
 
 if (DEBUG.enabled) console.log(`Scale: ${this.realisticScale ? 'Realistic' : 'Educational'}`);
 }
 
 updateOrbitalPaths() {
 // Remove existing orbital paths
 this.orbits.forEach(orbit => {
 if (orbit.parent) {
 orbit.parent.remove(orbit);
 }
 if (orbit.geometry) orbit.geometry.dispose();
 if (orbit.material) orbit.material.dispose();
 });
 this.orbits = [];
 
 // Recreate orbital paths for all planets
 const planetsToOrbit = ['mercury', 'venus', 'earth', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune'];
 
 planetsToOrbit.forEach(planetName => {
 const planet = this.planets[planetName];
 if (planet && planet.userData) {
 const distance = planet.userData.distance;
 const points = [];
 const segments = 128;
 
 for (let i = 0; i <= segments; i++) {
 const angle = (i / segments) * Math.PI * 2;
 points.push(new THREE.Vector3(
 distance * Math.cos(angle),
 0,
 distance * Math.sin(angle)
 ));
 }
 
 const geometry = new THREE.BufferGeometry().setFromPoints(points);
 const material = new THREE.LineBasicMaterial({
 color: 0x6688AA,
 transparent: true,
 opacity: 0.5
 });
 
 const orbit = new THREE.Line(geometry, material);
 orbit.visible = this.orbitsVisible;
 orbit.userData = { type: 'orbit', planet: planetName };
 
 planet.parent.add(orbit);
 this.orbits.push(orbit);
 }
 });
 
 // Also update Pluto if it exists
 if (this.planets.pluto && this.planets.pluto.userData) {
 const distance = this.planets.pluto.userData.distance;
 const points = [];
 const segments = 128;
 
 for (let i = 0; i <= segments; i++) {
 const angle = (i / segments) * Math.PI * 2;
 points.push(new THREE.Vector3(
 distance * Math.cos(angle),
 0,
 distance * Math.sin(angle)
 ));
 }
 
 const geometry = new THREE.BufferGeometry().setFromPoints(points);
 const material = new THREE.LineBasicMaterial({
 color: 0x6688AA,
 transparent: true,
 opacity: 0.5
 });
 
 const orbit = new THREE.Line(geometry, material);
 orbit.visible = this.orbitsVisible;
 orbit.userData = { type: 'orbit', planet: 'pluto' };
 
 this.planets.pluto.parent.add(orbit);
 this.orbits.push(orbit);
 }
 
 // Recreate moon orbital paths
 Object.values(this.planets).forEach(planet => {
 if (planet.userData.moons && planet.userData.moons.length > 0) {
 console.log(`[Orbits] Recreating ${planet.userData.moons.length} moon orbit(s) for ${planet.userData.name}`);
 planet.userData.moons.forEach(moon => {
 const moonDistance = moon.userData.distance;
 
 const curve = new THREE.EllipseCurve(
 0, 0,
 moonDistance, moonDistance,
 0, 2 * Math.PI,
 false,
 0
 );
 
 const points = curve.getPoints(128);
 const geometry = new THREE.BufferGeometry().setFromPoints(points);
 const material = new THREE.LineBasicMaterial({
 color: 0xAADDFF, // Brighter cyan for better visibility
 transparent: true,
 opacity: 0.7,
 linewidth: 2,
 depthTest: true,
 depthWrite: false
 });
 
 const orbitLine = new THREE.Line(geometry, material);
 orbitLine.rotation.x = Math.PI / 2;
 orbitLine.visible = this.orbitsVisible;
 orbitLine.renderOrder = 1;
 orbitLine.userData = { type: 'moonOrbit', moon: moon.userData.name, planet: planet.userData.name };
 planet.add(orbitLine);
 this.orbits.push(orbitLine);
 });
 }
 });
 
 if (DEBUG.enabled) console.log(` Orbits updated: ${this.orbits.length} (including moon orbits)`);
 }

 updateBelts() {
 // Update asteroid belt positions based on scale
 if (this.asteroidBelt && this.asteroidBelt.children) {
 // Define scale parameters for both modes
 const oldParams = this.realisticScale ? 
 { base: 125, spread: 25 } : // We're switching FROM educational TO realistic
 { base: 350, spread: 150 }; // We're switching FROM realistic TO educational
 
 const newParams = this.realisticScale ? 
 { base: 350, spread: 150 } : // Switching TO realistic
 { base: 125, spread: 25 }; // Switching TO educational - proportionally scaled (was 75Â±15)
 
 this.asteroidBelt.children.forEach(particleSystem => {
 if (particleSystem.geometry && particleSystem.geometry.attributes.position) {
 const positions = particleSystem.geometry.attributes.position.array;
 const particleCount = positions.length / 3;
 
 for (let i = 0; i < particleCount; i++) {
 const angle = Math.atan2(positions[i * 3 + 2], positions[i * 3]);
 const currentDist = Math.sqrt(positions[i * 3] * positions[i * 3] + positions[i * 3 + 2] * positions[i * 3 + 2]);
 const height = positions[i * 3 + 1];
 
 // Normalize from current scale to 0-1 range
 const normalizedDist = Math.max(0, Math.min(1, (currentDist - oldParams.base) / oldParams.spread));
 
 // Apply to new scale
 const newDistance = newParams.base + (normalizedDist * newParams.spread);
 
 positions[i * 3] = newDistance * Math.cos(angle);
 positions[i * 3 + 2] = newDistance * Math.sin(angle);
 }
 
 particleSystem.geometry.attributes.position.needsUpdate = true;
 }
 });
 }
 
 // Update Kuiper belt positions based on scale
 if (this.kuiperBelt && this.kuiperBelt.children) {
 // Define scale parameters for both modes
 const oldParams = this.realisticScale ? 
 { base: 2000, spread: 400 } : // We're switching FROM educational TO realistic
 { base: 6000, spread: 2250 }; // We're switching FROM realistic TO educational
 
 const newParams = this.realisticScale ? 
 { base: 6000, spread: 2250 } : // Switching TO realistic (30-55 AU, centered at 40 AU)
 { base: 2000, spread: 400 }; // Switching TO educational (beyond Neptune at 1542, includes Pluto at 2024)
 
 this.kuiperBelt.children.forEach(particleSystem => {
 if (particleSystem.geometry && particleSystem.geometry.attributes.position) {
 const positions = particleSystem.geometry.attributes.position.array;
 const particleCount = positions.length / 3;
 
 for (let i = 0; i < particleCount; i++) {
 const angle = Math.atan2(positions[i * 3 + 2], positions[i * 3]);
 const currentDist = Math.sqrt(positions[i * 3] * positions[i * 3] + positions[i * 3 + 2] * positions[i * 3 + 2]);
 const height = positions[i * 3 + 1];
 
 // Normalize from current scale to 0-1 range
 const normalizedDist = Math.max(0, Math.min(1, (currentDist - oldParams.base) / oldParams.spread));
 
 // Apply to new scale
 const newDistance = newParams.base + (normalizedDist * newParams.spread);
 
 positions[i * 3] = newDistance * Math.cos(angle);
 positions[i * 3 + 2] = newDistance * Math.sin(angle);
 }
 
 particleSystem.geometry.attributes.position.needsUpdate = true;
 }
 });
 }
 
 if (DEBUG.enabled) console.log(` Belts updated for ${this.realisticScale ? 'realistic' : 'educational'} scale`);
 }
 
 updateSpacecraftPositions() {
 // Update spacecraft positions based on scale mode
 if (!this.spacecraft || this.spacecraft.length === 0) return;
 
 // Scale factors for spacecraft distances
 const spacecraftScaleFactors = this.realisticScale ? {
 // Realistic scale - use much larger distances
 'Voyager 1': 4500, // 162 AU - way beyond planets
 'Voyager 2': 4200, // 135 AU
 'New Horizons': 2950, // 59 AU - beyond Neptune 
 'James Webb Space Telescope': 225, // At Earth's L2 point (1.5 million km, ~0.01 AU)
 'Pioneer 10': 4800, // 133 AU
 'Pioneer 11': 4400 // 106 AU
 } : {
 // Educational scale - proportionally compressed
 // Using Mercury (0.39 AU) = 20 as base scale factor = 51.28 units per AU
 'Voyager 1': 8307,  // 162 AU * 51.28 (was 300)
 'Voyager 2': 6923,  // 135 AU * 51.28 (was 280)
 'New Horizons': 3025, // 59 AU * 51.28 (was 85)
 'James Webb Space Telescope': 250, // At Earth's L2 point (scaled for visibility)
 'Pioneer 10': 6820,  // 133 AU * 51.28 (was 320)
 'Pioneer 11': 5436   // 106 AU * 51.28 (was 290)
 };
 
 this.spacecraft.forEach(spacecraft => {
 const userData = spacecraft.userData;
 if (!userData || userData.orbitPlanet) return; // Skip orbiters - they stay relative to planet
 
 const newDistance = spacecraftScaleFactors[userData.name];
 if (newDistance && userData.angle !== undefined) {
 // Update stored distance
 userData.distance = newDistance;
 
 // Update position
 spacecraft.position.x = newDistance * Math.cos(userData.angle);
 spacecraft.position.z = newDistance * Math.sin(userData.angle);
 
 if (DEBUG.enabled) console.log(` ${userData.name}: ${newDistance} units`);
 }
 });
 
 if (DEBUG.enabled) console.log(` Spacecraft positions updated for ${this.realisticScale ? 'realistic' : 'educational'} scale`);
 }
 
 updateCometPositions() {
 // Update comet orbit distances based on scale mode
 if (!this.comets || this.comets.length === 0) return;
 
 // Scale factors for comet distances (semi-major axis of their elliptical orbits)
 const cometScaleFactors = this.realisticScale ? {
 // Realistic scale - Halley's Comet: ~35 AU, Hale-Bopp: ~250 AU, NEOWISE: ~10 AU
 'Halley\'s Comet': 5250, // ~35 AU
 'Comet Hale-Bopp': 37500, // ~250 AU
 'Comet NEOWISE': 1500 // ~10 AU
 } : {
 // Educational scale - proportionally compressed (51.28 units per AU)
 'Halley\'s Comet': 1795,  // 35 AU * 51.28 (was 200)
 'Comet Hale-Bopp': 12820, // 250 AU * 51.28 (was 250)
 'Comet NEOWISE': 513      // 10 AU * 51.28 (was 180)
 };
 
 this.comets.forEach(comet => {
 const userData = comet.userData;
 if (!userData || !userData.name) return;
 
 const newDistance = cometScaleFactors[userData.name];
 if (newDistance !== undefined) {
 // Update stored distance (semi-major axis)
 userData.distance = newDistance;
 
 // Recalculate position based on current angle and eccentricity
 const e = userData.eccentricity;
 const a = userData.distance;
 const angle = userData.angle || 0;
 
 const cosAngle = Math.cos(angle);
 const sinAngle = Math.sin(angle);
 
 // Elliptical orbit formula
 const r = a * (1 - e * e) / (1 + e * cosAngle);
 comet.position.x = r * cosAngle;
 comet.position.z = r * sinAngle;
 comet.position.y = Math.sin(angle * 0.5) * 20;
 
 if (DEBUG.enabled) console.log(` ${userData.name}: ${newDistance} units (e=${e})`);
 }
 });
 
 if (DEBUG.enabled) console.log(` Comet positions updated for ${this.realisticScale ? 'realistic' : 'educational'} scale`);
 }
 
 updateDeepSpaceObjects() {
 // Update nebulae and galaxies positions based on scale mode
 const deepSpaceScale = this.realisticScale ? 2.5 : 1.0;
 
 // Update nebulae
 if (this.nebulae && this.nebulae.length > 0) {
 this.nebulae.forEach(nebula => {
 if (nebula.userData && nebula.userData.basePosition) {
 // Scale position from stored base position
 nebula.position.x = nebula.userData.basePosition.x * deepSpaceScale;
 nebula.position.y = nebula.userData.basePosition.y * deepSpaceScale;
 nebula.position.z = nebula.userData.basePosition.z * deepSpaceScale;
 }
 });
 }
 
 // Update galaxies
 if (this.galaxies && this.galaxies.length > 0) {
 this.galaxies.forEach(galaxy => {
 if (galaxy.userData && galaxy.userData.basePosition) {
 // Scale position from stored base position
 galaxy.position.x = galaxy.userData.basePosition.x * deepSpaceScale;
 galaxy.position.y = galaxy.userData.basePosition.y * deepSpaceScale;
 galaxy.position.z = galaxy.userData.basePosition.z * deepSpaceScale;
 }
 });
 }
 
 if (DEBUG.enabled) console.log(` Deep space objects updated for ${this.realisticScale ? 'realistic' : 'educational'} scale`);
 }

 getObjectInfo(object) {
 const userData = object.userData;
 const t = window.t || ((key) => key);
 
 // Translate object name
 const nameKey = userData.name?.toLowerCase().replace(/\s+/g, '');
 let translatedName = userData.name || 'Unknown';
 if (nameKey && window.t && window.t(nameKey) !== nameKey) {
 translatedName = t(nameKey);
 }
 
 // Translate object type
 const typeKey = 'type' + userData.type?.replace(/\s+/g, '');
 let translatedType = userData.type || 'Object';
 if (typeKey && window.t && window.t(typeKey) !== typeKey) {
 translatedType = t(typeKey);
 }
 
 // Safely format distance
 let distanceText;
 if (userData.distance === 0) {
 distanceText = t('centerSolarSystem');
 } else if (userData.parentPlanet) {
 // Translate parent planet name too
 const parentKey = userData.parentPlanet?.toLowerCase().replace(/\s+/g, '');
 const translatedParent = (parentKey && window.t && window.t(parentKey) !== parentKey) ? t(parentKey) : userData.parentPlanet;
 distanceText = `${t('orbitsParent')} ${translatedParent}`;
 } else if (typeof userData.distance === 'number') {
 distanceText = `${userData.distance.toFixed(1)} ${t('millionKmFromSun')}`;
 } else {
 distanceText = t('distanceVaries');
 }
 
 // Get translated description based on object name
 let description = userData.description || t('noDescription');
 const descKey = 'desc' + userData.name?.replace(/\s+/g, '');
 if (window.t && window.t(descKey) !== descKey) {
 description = t(descKey);
 }
 
 let info = {
 name: translatedName,
 type: translatedType,
 distance: distanceText,
 size: userData.realSize || (userData.radius ? `${userData.radius.toFixed(2)} units` : 'Unknown size'),
 description: description
 };

 // Add fun facts for kids (translated)
 if (userData.funFact) {
 const funFactKey = 'funFact' + userData.name?.replace(/\s+/g, '');
 let funFact = userData.funFact;
 if (window.t && window.t(funFactKey) !== funFactKey) {
 funFact = t(funFactKey);
 }
 info.description += `\n\n ${funFact}`;
 }

 // Add moon count for planets (translated)
 if (userData.moonCount > 0) {
 const moonText = userData.moonCount > 1 ? t('majorMoons') : t('majorMoon');
 info.description += `\n\n ${t('moonCount')} ${userData.moonCount} ${moonText} ${t('shownHere')}`;
 }

 return info;
 }

 focusOnObject(object, camera, controls) {
 if (!object || !object.userData) {
 console.warn(' Cannot focus on invalid object');
 return;
 }
 
 // Determine actual object size (not inflated glow size)
 const userData = object.userData;
 let actualRadius;
 
 if (userData.isSpacecraft || userData.isComet) {
 // Use actual size for spacecraft and comets, not glow/tail size
 actualRadius = userData.actualSize || 0.1;
 } else if (userData.type === 'Constellation') {
 // Constellations: use calculated radius (star pattern spread)
 actualRadius = userData.radius || 500;
 } else if (userData.type === 'Galaxy' || userData.type === 'Nebula') {
 // Distant deep-sky objects
 actualRadius = userData.radius || 300;
 } else {
 actualRadius = userData.radius || 10;
 }
 
 // Calculate appropriate viewing distance based on object type
 let distance;
 if (userData.type === 'Constellation') {
 // Constellations: Position camera to view the star pattern
 // They're at distance ~10000, so we need to be relatively close but not inside
 distance = actualRadius * 3; // View from 3x the pattern size
 } else if (userData.type === 'Galaxy') {
 // Galaxies: Distant objects, zoom to appreciate structure
 distance = actualRadius * 4;
 } else if (userData.type === 'Nebula') {
 // Nebulae: Clouds in space, zoom to show details
 distance = actualRadius * 3.5;
 } else if (userData.isSpacecraft && userData.distance > 100) {
 // Distant spacecraft: zoom in close enough to see them clearly
 distance = Math.max(actualRadius * 10, 5);
 } else if (userData.isSpacecraft && userData.orbitPlanet) {
 // ISS and orbital satellites: Close enough to see details but not too close
 // For tiny objects like ISS (size ~0.03), position camera at reasonable distance (1.0 units minimum)
 distance = Math.max(actualRadius * 15, 1.0);
 console.log(` [Satellite Chase-Cam] Camera distance: ${distance.toFixed(2)} (${actualRadius.toFixed(3)} Ã— 15, min 1.0) for ISS viewing`);
 } else if (userData.type === 'moon' && userData.orbitPlanet) {
 // Moons: Close chase-cam to see moon details and parent planet surface
 distance = Math.max(actualRadius * 4, 2);
 console.log(` [Moon Chase-Cam] Close distance: ${distance.toFixed(2)} for parent planet flyover`);
 } else if (userData.isSpacecraft) {
 // Other spacecraft: moderate zoom
 distance = Math.max(actualRadius * 8, 3);
 } else if (userData.isComet) {
 // Comets: zoom to see nucleus and inner coma details
 distance = Math.max(actualRadius * 12, 2);
 } else {
 // Regular objects: standard zoom
 distance = Math.max(actualRadius * 5, 10);
 }
 
 const targetPosition = new THREE.Vector3();
 
 // Special handling for constellations - use center of star pattern
 if (userData.type === 'Constellation' && userData.centerPosition) {
 targetPosition.set(
 userData.centerPosition.x,
 userData.centerPosition.y,
 userData.centerPosition.z
 );
 
 // Highlight this constellation and dim others
 this.highlightConstellation(object);
 } else {
 // Reset constellation highlighting if focusing on non-constellation
 this.resetConstellationHighlight();
 object.getWorldPosition(targetPosition);
 }
 

 // Store reference for tracking
 this.focusedObject = object;
 this.focusedObjectDistance = distance;
 this.focusedObjectStartTime = performance.now();

 if (DEBUG.enabled) console.log(` Focus: ${object.userData.name} (r:${actualRadius.toFixed(2)}, d:${distance.toFixed(2)})`);

 // Determine if this is a fast-moving object that needs special tracking
 const isOrbiter = userData.orbitPlanet || (userData.isSpacecraft && userData.speed);
 const isFastOrbiter = isOrbiter && userData.speed > 0.5;

 // Enable chase-cam co-rotation for ALL orbiting objects except planets
 // Camera will orbit WITH the object (spacecraft, moons, etc.)
 const isPlanetOrbitingSun = (userData.type === 'planet' || userData.isPlanet) && userData.orbitPlanet?.toLowerCase() === 'sun';
 
 if (userData.type === 'Constellation') {
     // Constellations: never follow
     this.cameraFollowMode = false;
     this.cameraCoRotateMode = false;
 } else if (userData.orbitPlanet && !isPlanetOrbitingSun) {
     // All objects orbiting a planet (spacecraft, moons, etc.): enable chase-cam
     this.cameraFollowMode = true;
     this.cameraCoRotateMode = true; // Chase-cam mode: camera orbits WITH object
     const objectType = userData.isSpacecraft ? 'spacecraft' : userData.type || 'orbiter';
     if (DEBUG.enabled) console.log(` Chase-cam co-rotation enabled for ${object.userData.name} (${objectType})`);
 } else if (isOrbiter) {
     // Other orbiters (planets around sun, comets): traditional tracking
     this.cameraFollowMode = true;
     this.cameraCoRotateMode = false;
     if (DEBUG.enabled) console.log(` Traditional tracking enabled for ${object.userData.name}`);
 } else {
     this.cameraFollowMode = false;
     this.cameraCoRotateMode = false;
 }

 // Adjust time speed based on object type
 // Fast-moving orbital objects (ISS, satellites) need slower time for observation
 if (userData.isSpacecraft && userData.orbitPlanet && !isPlanetOrbitingSun) {
     // Orbital spacecraft (ISS, satellites): slow to 0.1x for detailed observation
     if (window.app && window.app.timeSpeed !== 0) {
         window.app.timeSpeed = 0.1;
         console.log(` [Time Speed] Reduced to 0.1x for orbital spacecraft observation`);
     }
 } else if (userData.type === 'planet' || userData.isPlanet) {
     // Planets: return to normal 1x speed
     if (window.app && window.app.timeSpeed !== 0 && window.app.timeSpeed !== 1) {
         window.app.timeSpeed = 1;
         console.log(` [Time Speed] Restored to 1x for planet observation`);
     }
 }
 
 // Configure controls for focused object inspection
 let minDist, maxDist;
 
 if (userData.type === 'Constellation') {
 // Constellations: large viewing range since they're at distance 10000
 minDist = 100; // Don't get too close or you'll be inside stars
 maxDist = 20000; // Allow zooming far out
 } else if (userData.isSpacecraft && userData.orbitPlanet) {
 // ISS and orbital satellites: allow close inspection and wide zoom range
 minDist = 0.2; // Get close to see module details
 maxDist = 100; // Zoom out to see Earth + satellite in context
 console.log(` [ISS/Satellite Zoom] min: ${minDist}, max: ${maxDist}`);
 } else {
 minDist = Math.max(actualRadius * 0.5, 0.5); // Allow zooming to half the radius
 maxDist = Math.max(actualRadius * 100, 1000); // Allow zooming far out
 }
 
 controls.minDistance = minDist;
 controls.maxDistance = maxDist;
 
 // Configure controls based on object type
 controls.enableRotate = true;
 controls.enableZoom = true;
 // Disable panning for ISS/satellites to keep them centered (Earth stays in view)
 controls.enablePan = (userData.isSpacecraft && userData.orbitPlanet) ? false : true;
 controls.autoRotate = false;
 
 if (userData.isSpacecraft && userData.orbitPlanet) {
 console.log(` [ISS Controls] Panning disabled to keep ISS centered and Earth in view`);
 }
 
 // Smooth camera transition
 const startPos = camera.position.clone();
 const startTarget = controls.target.clone();
 
 // For fast orbiters (like ISS), do NOT use relative offset if isSpacecraft
 let useRelativeOffset = false;
 let parentPlanet = null;
 let relativeOffset = null;

 if (isFastOrbiter && userData.orbitPlanet && !userData.isSpacecraft) {
     parentPlanet = this.planets[userData.orbitPlanet.toLowerCase()];
     if (parentPlanet) {
         useRelativeOffset = true;
         relativeOffset = targetPosition.clone().sub(parentPlanet.position);
         if (DEBUG.enabled) console.log(` Fast orbiter: using relative offset from ${userData.orbitPlanet}`);
     }
 }
 
 // Calculate camera end position based on object type
 let endPos;

 if (userData.type === 'Constellation') {
     // For constellations: We view them from NEAR the origin (Earth's perspective)
     // looking OUTWARD toward the constellation at distance 10000
     
     // Direction from origin to constellation center
     const directionToConstellation = targetPosition.clone().normalize();
     
     // Position camera closer to origin, looking outward at constellation
     // This simulates viewing from Earth (origin) toward the stars
     const viewDistance = 200; // Close to origin for proper viewing angle
     endPos = new THREE.Vector3(
         directionToConstellation.x * viewDistance,
         directionToConstellation.y * viewDistance,
         directionToConstellation.z * viewDistance
     );
     
     // Important: Set target FIRST, then position camera looking FROM position TO target
     // This way camera faces the constellation
     controls.target.copy(targetPosition); // Look at constellation center at distance 10000
 } else if (userData.isSpacecraft && userData.orbitPlanet) {
     // For ISS and other spacecraft: position camera to see BOTH ISS and Earth
     parentPlanet = this.planets[userData.orbitPlanet.toLowerCase()];
     if (parentPlanet) {
         // Get direction from Earth to ISS (radial direction)
         const earthPos = new THREE.Vector3();
         parentPlanet.getWorldPosition(earthPos);
         const issDirection = targetPosition.clone().sub(earthPos).normalize();
         
         // Position camera OUTSIDE the orbit, looking inward at both ISS and Earth
         // This ensures Earth is always visible as backdrop
         const cameraDistance = distance * 1.5; // Further out to see both
         endPos = new THREE.Vector3(
             targetPosition.x + issDirection.x * cameraDistance, // Outside the orbit
             targetPosition.y + cameraDistance * 0.4, // Elevated view
             targetPosition.z + issDirection.z * cameraDistance
         );
         
         controls.target.copy(targetPosition); // Look at ISS (Earth will be behind it)
     } else {
         // Fallback: simple positioning
         const angle = Math.random() * Math.PI * 2;
         endPos = new THREE.Vector3(
             targetPosition.x + Math.cos(angle) * distance,
             targetPosition.y + distance * 0.3,
             targetPosition.z + Math.sin(angle) * distance
         );
         controls.target.copy(targetPosition);
     }
 } else if (userData.isSpacecraft) {
     // Other spacecraft without orbit: position camera at a fixed offset
     endPos = new THREE.Vector3(
         targetPosition.x,
         targetPosition.y + distance * 0.3,
         targetPosition.z + distance
     );
     controls.target.copy(targetPosition);
 } else if (userData.type === 'moon' && userData.orbitPlanet) {
     // Moons: Chase-cam perspective showing moon and parent planet surface
     parentPlanet = this.planets[userData.orbitPlanet.toLowerCase()];
     if (parentPlanet) {
         // Calculate moon direction from planet
         const moonDirection = targetPosition.clone().sub(parentPlanet.position).normalize();
         
         // Position camera behind and slightly above moon for chase-cam effect
         const offsetDistance = distance;
         endPos = new THREE.Vector3(
             targetPosition.x - moonDirection.x * offsetDistance * 0.5, // Behind moon
             targetPosition.y + offsetDistance * 0.3, // Above
             targetPosition.z - moonDirection.z * offsetDistance * 0.5
         );
         
         controls.target.copy(targetPosition); // Look at moon
         console.log(` [Moon Chase-Cam] Camera positioned behind ${userData.name} for parent planet flyover`);
     } else {
         // Fallback: static angle
         const angle = Math.random() * Math.PI * 2;
         const elevation = 0.4;
         endPos = new THREE.Vector3(
             targetPosition.x + Math.cos(angle) * distance,
             targetPosition.y + distance * elevation,
             targetPosition.z + Math.sin(angle) * distance
         );
         controls.target.copy(targetPosition);
     }
 } else if (userData.type === 'planet' || userData.isPlanet) {
     // Planets: Cinematic angles that showcase their features
     const planetName = userData.name.toLowerCase();
     let angleOffset = 0;
     let elevationFactor = 0.4;
     let distanceMultiplier = 1.0;
     
     // Customize camera angle per planet for best feature showcase
     if (planetName === 'saturn') {
         // Saturn: View rings at a dramatic angle
         elevationFactor = 0.25; // Lower angle to see rings better
         angleOffset = Math.PI * 0.3; // 54 degrees for ring visibility
         distanceMultiplier = 1.2; // Pull back a bit to see full ring system
         console.log(` [Saturn] Ring showcase view`);
     } else if (planetName === 'jupiter') {
         // Jupiter: Slight elevation to show bands and Great Red Spot
         elevationFactor = 0.35;
         angleOffset = Math.PI * 0.15; // 27 degrees
         console.log(` [Jupiter] Band showcase view`);
     } else if (planetName === 'mars') {
         // Mars: Medium elevation to show polar caps
         elevationFactor = 0.45;
         angleOffset = Math.PI * 0.25; // 45 degrees
         console.log(` [Mars] Polar cap view`);
     } else if (planetName === 'earth') {
         // Earth: Beautiful oblique angle
         elevationFactor = 0.5;
         angleOffset = Math.PI * 0.2; // 36 degrees
         console.log(` [Earth] Oblique orbital view`);
     } else if (planetName === 'venus' || planetName === 'mercury') {
         // Inner planets: Higher elevation
         elevationFactor = 0.55;
         angleOffset = Math.PI * 0.3;
         console.log(` [${planetName}] High angle view`);
     } else if (planetName === 'uranus' || planetName === 'neptune') {
         // Ice giants: Moderate angle with slight randomness
         elevationFactor = 0.4 + Math.random() * 0.2;
         angleOffset = Math.PI * 0.25;
         console.log(` [${planetName}] Ice giant showcase`);
     } else {
         // Default planet view
         elevationFactor = 0.4;
         angleOffset = Math.PI * 0.3;
     }
     
     const adjustedDistance = distance * distanceMultiplier;
     endPos = new THREE.Vector3(
         targetPosition.x + Math.cos(angleOffset) * adjustedDistance,
         targetPosition.y + adjustedDistance * elevationFactor,
         targetPosition.z + Math.sin(angleOffset) * adjustedDistance
     );
     controls.target.copy(targetPosition);
 } else if (userData.isComet) {
     // Comets: Position camera to showcase tail and nucleus
     // Camera should be positioned to see both the coma and the tail streaming away from sun
     const sunPosition = this.sun ? this.sun.position : new THREE.Vector3(0, 0, 0);
     const sunDirection = targetPosition.clone().sub(sunPosition).normalize();
     
     // Position camera at an angle to see both nucleus and tail
     const sideVector = new THREE.Vector3(-sunDirection.z, 0, sunDirection.x).normalize();
     const angleVariation = Math.random() * Math.PI * 0.3 - Math.PI * 0.15; // Â±27 degrees
     
     endPos = targetPosition.clone()
         .add(sunDirection.clone().multiplyScalar(distance * 0.5)) // Partially in front
         .add(sideVector.multiplyScalar(distance * Math.sin(angleVariation) * 0.8)) // To the side
         .add(new THREE.Vector3(0, distance * 0.4, 0)); // Above to see tail shape
     
     controls.target.copy(targetPosition);
     console.log(` [Comet] Tail showcase view - camera positioned to see nucleus and tail`);
 } else if (userData.type === 'asteroid') {
     // Asteroids: Close dramatic angle to show irregular shape
     const angle = Math.random() * Math.PI * 2;
     const elevation = 0.3 + Math.random() * 0.2; // Lower angle (0.3-0.5) for drama
     endPos = new THREE.Vector3(
         targetPosition.x + Math.cos(angle) * distance * 0.8,
         targetPosition.y + distance * elevation,
         targetPosition.z + Math.sin(angle) * distance * 0.8
     );
     controls.target.copy(targetPosition);
     console.log(` [Asteroid] Close dramatic angle for irregular shape showcase`);
 } else {
     // Other objects: Dynamic positioning with slight variation
     const variation = Math.random() * 0.2 - 0.1; // -0.1 to +0.1 variation
     endPos = new THREE.Vector3(
         targetPosition.x + distance * variation,
         targetPosition.y + distance * (0.3 + variation),
         targetPosition.z + distance * (1.0 + variation)
     );
 }
 
 const duration = isFastOrbiter ? 1000 : 1500; // Faster transition for fast orbiters
 const startTime = performance.now();
 
 const animate = () => {
 const elapsed = performance.now() - startTime;
 const progress = Math.min(elapsed / duration, 1);
 const eased = 1 - Math.pow(1 - progress, 3); // Cubic ease-out
 
 // Update target position differently based on object type
 if (userData.type === 'Constellation') {
 // Constellations: keep static target (don't update position)
 // targetPosition already set to constellation center
 } else if (useRelativeOffset && progress < 1) {
 // For fast orbiters during transition: maintain relative offset from parent
 const planetPos = parentPlanet.position.clone();
 targetPosition.copy(planetPos).add(relativeOffset);
 endPos.set(
 targetPosition.x,
 targetPosition.y + distance * 0.3,
 targetPosition.z + distance
 );
 } else if (progress < 1) {
 // For regular objects or final frame: use actual position
 object.getWorldPosition(targetPosition);
 }
 
 camera.position.lerpVectors(startPos, endPos, eased);
 
 // For constellations, ensure camera always looks at the constellation
 if (userData.type === 'Constellation') {
 camera.lookAt(targetPosition);
 controls.target.copy(targetPosition);
 } else {
 controls.target.copy(targetPosition);
 }
 
 controls.update();
 
 if (progress < 1) {
 requestAnimationFrame(animate);
 } else {
 // Transition complete - enable smooth following
 if (isOrbiter) {
 this.cameraFollowMode = true;
 if (DEBUG.enabled) console.log(` Camera follow mode ENABLED for ${object.userData.name}`);
 }
 }
 };
 
 animate();
 }
 
 updateCameraTracking(camera, controls) {
 // TRACKING INDICATOR REMOVED - it was distracting
 
 // Exit if no focused object or tracking disabled
 if (!this.focusedObject || !this.cameraFollowMode) {
 return;
 }
 
 const object = this.focusedObject;
 const userData = object.userData;
 const targetPosition = new THREE.Vector3();
 object.getWorldPosition(targetPosition);
 
 if (this.cameraCoRotateMode && userData.orbitPlanet) {
 // CO-ROTATION MODE: Camera orbits WITH the spacecraft (ISS, Hubble, etc.)
 // Camera maintains fixed relative position in the spacecraft's orbital frame
 
 const parentPlanet = this.planets[userData.orbitPlanet.toLowerCase()];
 if (parentPlanet) {
 const offsetDistance = this.focusedObjectDistance || 3;
 
 // Get vector from planet to ISS (radial direction)
 const radialDirection = targetPosition.clone().sub(parentPlanet.position);
 const orbitRadius = radialDirection.length();
 radialDirection.normalize();
 
 // Calculate tangent direction (perpendicular to radial, in orbital plane)
 // For a counter-clockwise orbit when viewed from above (standard), tangent is:
 // cross product of radial with up vector (0, 1, 0)
 const up = new THREE.Vector3(0, 1, 0);
 const tangentDirection = new THREE.Vector3().crossVectors(up, radialDirection).normalize();
 
 // If orbit is inclined significantly, use actual orbital motion
 if (userData.orbitalVelocity) {
 tangentDirection.copy(userData.orbitalVelocity).normalize();
 }
 
 // Cinematic co-rotation: Add subtle variation over time for more dynamic view
 const time = performance.now() * 0.0001; // Slow oscillation
 const breathingFactor = Math.sin(time) * 0.1; // Â±10% distance variation
 const adjustedDistance = offsetDistance * (1.0 + breathingFactor);
 
 // ULTRA-CLOSE chase-cam: Position camera very close behind and slightly above ISS
 // This creates a dramatic view with Earth surface rushing by below
 const cameraPosition = targetPosition.clone()
 .add(tangentDirection.clone().multiplyScalar(-adjustedDistance * 0.4)) // Close behind (40% of distance)
 .add(radialDirection.clone().multiplyScalar(adjustedDistance * 0.15)) // Minimal outward (15%)
 .add(up.multiplyScalar(adjustedDistance * 0.25)); // Slightly above (25%)
 
 camera.position.copy(cameraPosition);
 
 // Always look at ISS
 controls.target.copy(targetPosition);
 controls.update();
 }
 } else {
 // TRADITIONAL TRACKING MODE: Camera follows but doesn't co-rotate
 
 // Determine smooth factor based on object speed
 const isFastOrbiter = userData.orbitPlanet && userData.speed && userData.speed > 0.5;
 const smoothFactor = isFastOrbiter ? 0.25 : 0.1;
 
 // Smoothly update controls target to follow the object
 const currentTarget = controls.target.clone();
 controls.target.lerpVectors(currentTarget, targetPosition, smoothFactor);
 
 // Calculate offset from target to camera
 const offset = camera.position.clone().sub(currentTarget);
 
 // Move camera to maintain the same relative position
 camera.position.copy(targetPosition).add(offset);
 
 controls.update();
 }
 }

 createLabels() {
 // Create CSS2D labels for all major objects
 this.labels = [];
 
 // Helper function to create a label
 const createLabel = (object, text) => {
 if (!object || !object.userData) return;
 
 const labelDiv = document.createElement('div');
 labelDiv.className = 'object-label';
 labelDiv.textContent = text || object.userData.name;
 labelDiv.style.color = 'white';
 labelDiv.style.fontSize = '14px';
 labelDiv.style.fontFamily = "'Poppins', 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif";
 labelDiv.style.padding = '2px 6px';
 labelDiv.style.background = 'rgba(0, 0, 0, 0.7)';
 labelDiv.style.borderRadius = '4px';
 labelDiv.style.pointerEvents = 'none';
 labelDiv.style.userSelect = 'none';
 
 const label = new CSS2DObject(labelDiv);
 label.position.set(0, object.userData.radius * 1.5 || 5, 0);
 label.visible = false; // Start hidden
 object.add(label);
 
 object.userData.label = label;
 this.labels.push(label);
 };
 
 // Add labels to Sun
 if (this.sun) {
 createLabel(this.sun, ' Sun');
 }
 
 // Add labels to planets
 Object.entries(this.planets).forEach(([name, planet]) => {
 if (planet) {
 const emoji = {
 'mercury': '', 'venus': '', 'earth': '', 'mars': '',
 'jupiter': '', 'saturn': '', 'uranus': '', 'neptune': ''
 }[name.toLowerCase()] || '';
 createLabel(planet, `${emoji} ${planet.userData.name}`);
 
 // Add labels to moons
 if (planet.userData.moons) {
 planet.userData.moons.forEach(moon => {
 createLabel(moon, ` ${moon.userData.name}`);
 });
 }
 }
 });
 
 // Add labels to spacecraft
 if (this.spacecraft) {
 this.spacecraft.forEach(craft => {
 createLabel(craft, ` ${craft.userData.name}`);
 });
 }
 
 // Add labels to satellites
 if (this.satellites) {
 this.satellites.forEach(sat => {
 createLabel(sat, ` ${sat.userData.name}`);
 });
 }
 
 // Add labels to distant stars
 if (this.distantStars) {
 this.distantStars.forEach(star => {
 createLabel(star, ` ${star.userData.name}`);
 });
 }
 
 // Add labels to nebulae
 if (this.nebulae) {
 this.nebulae.forEach(nebula => {
 createLabel(nebula, ` ${nebula.userData.name}`);
 });
 }
 
 // Add labels to constellations
 if (this.constellations) {
 this.constellations.forEach(constellation => {
 createLabel(constellation, ` ${constellation.userData.name}`);
 });
 }
 }

 toggleLabels(visible) {
 console.log(` toggleLabels called with visible=${visible}, labels.length=${this.labels?.length || 0}`);
 
 if (!this.labels || this.labels.length === 0) {
 console.warn(' No labels to toggle - labels array is empty or undefined');
 console.log(' this.labels:', this.labels);
 return;
 }
 
 // Use the passed visibility state, or toggle based on first label's current state
 const newVisibility = visible !== undefined ? visible : !this.labels[0].visible;
 
 this.labels.forEach((label, index) => {
 label.visible = newVisibility;
 if (index < 3 && DEBUG.enabled) {
 console.log(` Label ${index}: ${label.element?.textContent || 'no text'} -> visible=${newVisibility}`);
 }
 });
 
 console.log(` Labels now: ${newVisibility ? 'VISIBLE ' : 'HIDDEN '} (${this.labels.length} labels toggled)`);
 }

 getExplorerContent(focusCallback) {
 const categories = [
 {
 title: ' The Sun',
 items: [
 { name: ' Sun', onClick: () => focusCallback(this.sun) }
 ]
 },
 {
 title: ' Inner Planets (Rocky)',
 items: [
 { name: ' Mercury', onClick: () => focusCallback(this.planets.mercury) },
 { name: ' Venus', onClick: () => focusCallback(this.planets.venus) },
 { name: ' Earth', onClick: () => focusCallback(this.planets.earth) },
 { name: ' Moon', onClick: () => focusCallback(this.moons.moon) },
 { name: ' Mars', onClick: () => focusCallback(this.planets.mars) },
 { name: ' Phobos', onClick: () => focusCallback(this.moons.phobos) },
 { name: ' Deimos', onClick: () => focusCallback(this.moons.deimos) }
 ]
 },
 {
 title: ' Asteroid Belt',
 items: [
 { name: ' Asteroid Belt', onClick: () => focusCallback(this.asteroidBelt) }
 ]
 },
 {
 title: ' Outer Planets (Gas Giants)',
 items: [
 { name: ' Jupiter', onClick: () => focusCallback(this.planets.jupiter) },
 { name: ' Io', onClick: () => focusCallback(this.moons.io) },
 { name: ' Europa', onClick: () => focusCallback(this.moons.europa) },
 { name: ' Ganymede', onClick: () => focusCallback(this.moons.ganymede) },
 { name: ' Callisto', onClick: () => focusCallback(this.moons.callisto) },
 { name: ' Saturn', onClick: () => focusCallback(this.planets.saturn) },
 { name: ' Titan', onClick: () => focusCallback(this.moons.titan) },
 { name: ' Enceladus', onClick: () => focusCallback(this.moons.enceladus) },
 { name: ' Rhea', onClick: () => focusCallback(this.moons.rhea) }
 ]
 },
 {
 title: ' Ice Giants',
 items: [
 { name: ' Uranus', onClick: () => focusCallback(this.planets.uranus) },
 { name: ' Titania', onClick: () => focusCallback(this.moons.titania) },
 { name: ' Miranda', onClick: () => focusCallback(this.moons.miranda) },
 { name: ' Neptune', onClick: () => focusCallback(this.planets.neptune) },
 { name: ' Triton', onClick: () => focusCallback(this.moons.triton) }
 ]
 },
 {
 title: ' Kuiper Belt & Dwarf Planets',
 items: [
 { name: ' Pluto', onClick: () => focusCallback(this.planets.pluto) },
 { name: ' Charon', onClick: () => focusCallback(this.moons.charon) },
 { name: ' Kuiper Belt', onClick: () => focusCallback(this.kuiperBelt) }
 ]
 },
 {
 title: ' Comets',
 items: this.comets.map(comet => ({
 name: ` ${comet.userData.name}`,
 onClick: () => focusCallback(comet)
 }))
 },
 {
 title: ' Satellites & Space Stations',
 items: this.satellites.map(sat => ({
 name: ` ${sat.userData.name}`,
 onClick: () => focusCallback(sat)
 }))
 },
 {
 title: ' Spacecraft & Probes',
 items: this.spacecraft.map(craft => ({
 name: ` ${craft.userData.name}`,
 onClick: () => focusCallback(craft)
 }))
 },
 {
 title: ' Distant Stars',
 items: this.distantStars.map(star => ({
 name: ` ${star.userData.name}`,
 onClick: () => focusCallback(star)
 }))
 },
 {
 title: ' Nebulae',
 items: this.nebulae.map(nebula => ({
 name: ` ${nebula.userData.name}`,
 onClick: () => focusCallback(nebula)
 }))
 },
 {
 title: ' Galaxies',
 items: this.galaxies.map(galaxy => ({
 name: ` ${galaxy.userData.name}`,
 onClick: () => focusCallback(galaxy)
 }))
 },
 {
 title: ' Constellations',
 items: this.constellations.map(constellation => ({
 name: ` ${constellation.userData.name}`,
 onClick: () => focusCallback(constellation)
 }))
 }
 ];
 
 // Debug logging for constellations
 console.log(`[Explorer] Constellations array length: ${this.constellations?.length || 0}`);
 if (this.constellations?.length > 0) {
 console.log(`[Explorer] First constellation: ${this.constellations[0]?.userData?.name}`);
 }
 
 // Filter out categories with no items (empty arrays)
 const filtered = categories.filter(category => category.items && category.items.length > 0);
 console.log(`[Explorer] Total categories: ${categories.length}, After filter: ${filtered.length}`);
 return filtered;
 }
 
 getQuickNavTargets() {
 // Returns array of quick navigation targets for VR menu and quick nav dropdown
 const targets = [];
 
 // Add key solar system objects
 if (this.planets.earth) targets.push({ id: 'earth', label: ' Earth', object: this.planets.earth });
 if (this.planets.mars) targets.push({ id: 'mars', label: ' Mars', object: this.planets.mars });
 if (this.planets.jupiter) targets.push({ id: 'jupiter', label: ' Jupiter', object: this.planets.jupiter });
 if (this.planets.saturn) targets.push({ id: 'saturn', label: ' Saturn', object: this.planets.saturn });
 
 // Add some moons
 if (this.moons.moon) targets.push({ id: 'moon', label: ' Moon', object: this.moons.moon });
 if (this.moons.europa) targets.push({ id: 'europa', label: ' Europa', object: this.moons.europa });
 if (this.moons.titan) targets.push({ id: 'titan', label: ' Titan', object: this.moons.titan });
 
 // Add some interesting objects
 if (this.satellites && this.satellites.length > 0) {
 const iss = this.satellites.find(s => s.userData.name.includes('ISS'));
 if (iss) targets.push({ id: 'iss', label: ' ISS', object: iss });
 }
 
 if (this.spacecraft && this.spacecraft.length > 0) {
 const voyager1 = this.spacecraft.find(s => s.userData.name.includes('Voyager 1'));
 if (voyager1) targets.push({ id: 'voyager-1', label: ' Voyager 1', object: voyager1 });
 }
 
 if (this.nebulae && this.nebulae.length > 0) {
 const orion = this.nebulae.find(n => n.userData.name.includes('Orion'));
 if (orion) targets.push({ id: 'orion-nebula', label: ' Orion Nebula', object: orion });
 }
 
 if (this.galaxies && this.galaxies.length > 0) {
 const andromeda = this.galaxies.find(g => g.userData.name.includes('Andromeda'));
 if (andromeda) targets.push({ id: 'andromeda-galaxy', label: ' Andromeda', object: andromeda });
 }
 
 return targets;
 }
 
 refreshExplorerContent() {
 // Refresh the explorer menu with all loaded objects
 if (!this.uiManager) return;
 
 const focusCallback = (obj) => {
 if (obj) {
 const info = this.getObjectInfo(obj);
 this.uiManager.updateInfoPanel(info);
 this.focusOnObject(obj, window.app?.sceneManager?.camera, window.app?.sceneManager?.controls);
 }
 };
 
 const explorerContent = this.getExplorerContent(focusCallback);
 if (explorerContent && Array.isArray(explorerContent)) {
 this.uiManager.updateExplorer(' Explore the Solar System', explorerContent);
 console.log(` Explorer menu refreshed with ${explorerContent.length} categories`);
 }
 }
}


// ===========================
// TOPIC MANAGER
// ===========================
// TOPIC MANAGER (UNUSED - Commented out for single-topic app)
// ===========================
/* UNUSED CLASS - Kept for reference if multi-topic support needed in future
class TopicManager {
 constructor(sceneManager, uiManager) {
 this.sceneManager = sceneManager;
 this.uiManager = uiManager;
 this.currentModule = null;
 this.currentTopicId = null;
 // Initialize with default slider value (5 = 1000x speed)
 this.timeSpeed = 1000;
 this.brightnessMultiplier = 0.5;
 this.clickTimeout = null;
 
 // Modules - Only Solar System experience retained
 this.modules = {
 'solar-system': new SolarSystemModule(uiManager)
 // Other modules removed - focusing on solar system only
 };

 this.setupControls();
 }

 setupControls() {
 // Topic navigation with event delegation
 const navButtons = document.querySelectorAll('.nav-btn');
 navButtons.forEach(btn => {
 btn.addEventListener('click', () => this.handleTopicChange(btn), { passive: true });
 });

 // Time speed control (slider)
 const timeSpeedSlider = document.getElementById('time-speed');
 const timeSpeedLabel = document.getElementById('time-speed-label');
 
 // Time speed presets (seconds of simulated time per real second)
 // Earth orbit = 31,557,600 seconds (1 year)
 // For smooth animation: lower values = slower, more visible movement
 const speedValues = [
 0, // 0: Paused
 0.1, // 1: 0.1 sec/sec (nearly real-time, very slow)
 1, // 2: 1 sec/sec (real-time)
 10, // 3: 10 sec/sec
 100, // 4: 100 sec/sec
 1000, // 5: 1000 sec/sec (default - ~16 min/sec)
 10000, // 6: 10000 sec/sec (~2.7 hrs/sec)
 100000, // 7: 100000 sec/sec (~1 day/sec)
 500000, // 8: 500000 sec/sec (~5 days/sec)
 1000000, // 9: 1000000 sec/sec (~11 days/sec)
 5000000, // 10: 5000000 sec/sec (~58 days/sec)
 10000000, // 11: 10000000 sec/sec (~115 days/sec)
 525960 // 12: Earth orbit in 1 minute (max speed)
 ];

 const speedLabels = [
 'Paused',
 '0.1x',
 '1x Real-time',
 '10x',
 '100x',
 '1000x',
 '10,000x',
 '~1 day/sec',
 '~5 days/sec',
 '~11 days/sec',
 '~2 months/sec',
 '~4 months/sec',
 'Earth orbit/min'
 ];
 
 const updateSpeed = (index) => {
 const speed = speedValues[index];
 this.timeSpeed = speed;
 
 // Update App's timeSpeed as well
 if (window.app) {
 window.app.timeSpeed = speed;
 }
 
 // Update label
 if (timeSpeedLabel) {
 timeSpeedLabel.textContent = speedLabels[index];
 }
 
 // Always log speed changes for debugging
 console.log(`â± Speed changed to: ${speedLabels[index]} (${speed}x)`);
 };
 
 if (timeSpeedSlider) {
 timeSpeedSlider.addEventListener('input', (e) => {
 updateSpeed(parseInt(e.target.value, 10));
 }, { passive: true });
 
 // Set initial speed
 updateSpeed(parseInt(timeSpeedSlider.value, 10));
 }

 // Scale toggle button
 const scaleButton = document.getElementById('toggle-scale');
 if (scaleButton) {
 scaleButton.addEventListener('click', () => {
 if (this.solarSystemModule) {
 this.solarSystemModule.realisticScale = !this.solarSystemModule.realisticScale;
 scaleButton.classList.toggle('active');
 scaleButton.textContent = this.solarSystemModule.realisticScale ? 
 '?? Realistic Scale' : '?? Educational Scale';
 
 // Recalculate positions with new scale
 this.solarSystemModule.updateScale();
 }
 }, { passive: true });
 }
 
 // Labels toggle button
 const labelsButton = document.getElementById('toggle-details');
 if (labelsButton) {
 // Set initial button state
 labelsButton.textContent = ' Labels OFF';
 labelsButton.classList.remove('toggle-on');
 
 labelsButton.addEventListener('click', () => {
 const currentModule = this.solarSystemModule;
 if (currentModule && currentModule.toggleLabels) {
 // Toggle visibility using SceneManager's labelsVisible state
 if (this.sceneManager) {
 this.sceneManager.labelsVisible = !this.sceneManager.labelsVisible;
 currentModule.toggleLabels(this.sceneManager.labelsVisible);
 labelsButton.classList.toggle('toggle-on', this.sceneManager.labelsVisible);
 labelsButton.textContent = this.sceneManager.labelsVisible ? 
 ' Labels ON' : ' Labels OFF';
 if (DEBUG.enabled) console.log(` Labels toggled: ${this.sceneManager.labelsVisible ? 'ON' : 'OFF'}`);
 }
 }
 }, { passive: true });
 }
 
 // Reset view button
 const resetButton = document.getElementById('reset-view');
 if (resetButton) {
 resetButton.addEventListener('click', () => {
 // Clear focus from any object
 if (this.solarSystemModule) {
 this.solarSystemModule.focusedObject = null;
 }
 this.sceneManager.resetCamera();
 }, { passive: true });
 }

 // Tracking indicator close button
 const trackingClose = document.querySelector('#tracking-indicator .tracking-close');
 if (trackingClose) {
 trackingClose.addEventListener('click', () => {
 if (this.solarSystemModule) {
 this.solarSystemModule.cameraFollowMode = false;
 }
 }, { passive: true });
 }

 // Canvas click for object selection (debounced)
 this.sceneManager.renderer.domElement.addEventListener('click', (e) => {
 if (this.clickTimeout) return;
 this.clickTimeout = setTimeout(() => {
 this.clickTimeout = null;
 }, 300);
 this.handleCanvasClick(e);
 });
 }

 handleTopicChange(btn) {
 const topic = btn.dataset.topic;
 if (topic === this.currentTopicId) return; // Already loaded
 
 this.loadTopic(topic);
 document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
 btn.classList.add('active');
 }

 async loadTopic(topicId) {
 try {
 this.uiManager.showLoading(`Loading ${topicId}...`);

 // Cleanup current module
 if (this.currentModule) {
 this.currentModule.cleanup(this.sceneManager.scene);
 }

 // Clear scene
 this.sceneManager.clear();

 // Load new module
 const module = this.modules[topicId];
 if (module) {
 await module.init(this.sceneManager.scene);
 this.currentModule = module;
 this.currentTopicId = topicId;
 
 // Update explorer with focus callback
 const focusCallback = (obj) => {
 if (obj) {
 const info = module.getObjectInfo(obj);
 this.uiManager.updateInfoPanel(info);
 module.focusOnObject(obj, this.sceneManager.camera, this.sceneManager.controls);
 }
 };
 
 this.uiManager.updateExplorer(
 `?? Explore ${topicId}`, 
 module.getExplorerContent(focusCallback)
 );
 } else {
 console.warn(`Module ${topicId} not yet implemented`);
 this.uiManager.showLoading(`${topicId} coming soon!`);
 setTimeout(() => this.loadTopic('solar-system'), 2000);
 return;
 }

 this.uiManager.hideLoading();
 // Don't reset camera automatically - user might have an object focused
 // this.sceneManager.resetCamera();
 this.sceneManager.updateBrightness(this.brightnessMultiplier);
 } catch (error) {
 console.error('Error loading topic:', error);
 this.uiManager.showLoading('Error loading topic. Please refresh.');
 }
 }

 handleCanvasClick(event) {
 if (!this.currentModule || event.target.tagName !== 'CANVAS') return;

 const rect = this.sceneManager.renderer.domElement.getBoundingClientRect();
 this.sceneManager.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
 this.sceneManager.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

 this.sceneManager.raycaster.setFromCamera(this.sceneManager.mouse, this.sceneManager.camera);
 const intersects = this.sceneManager.raycaster.intersectObjects(
 this.currentModule.getSelectableObjects(), 
 false
 );

 if (intersects.length > 0) {
 const object = intersects[0].object;
 const info = this.currentModule.getObjectInfo(object);
 this.uiManager.updateInfoPanel(info);
 this.currentModule.focusOnObject(object, this.sceneManager.camera, this.sceneManager.controls);
 }
 }

 update(deltaTime) {
 if (this.currentModule) {
 this.currentModule.update(deltaTime, this.timeSpeed, this.sceneManager.camera, this.sceneManager.controls);
 }
 }
}
*/ // END OF UNUSED TopicManager CLASS

// Function to toggle pause
let isPaused = false;
function togglePause() {
 isPaused = !isPaused;
 if (isPaused) {
 // Logic to pause the game
 // For example, set app.timeSpeed = 0 or call a pause function
 if (window.app) {
 window.app.timeSpeed = 0;
 if (window.app.sceneManager) {
 window.app.sceneManager.vrStatusMessage = 'â¸ Paused';
 window.app.sceneManager.requestVRMenuRefresh();
 }
 }
 } else {
 // Logic to resume the game
 if (window.app) {
 window.app.timeSpeed = 1;
 if (window.app.sceneManager) {
 window.app.sceneManager.vrStatusMessage = ' Playing';
 window.app.sceneManager.requestVRMenuRefresh();
 }
 }
 }
}

// Update the VR navigation setup to include thumbstick press
function setupVRNavigation() {
 // This assumes you have a way to get the VR controllers
 if (window.app && window.app.sceneManager && window.app.sceneManager.controllers) {
 window.app.sceneManager.controllers.forEach(controller => {
 // Listen for thumbstick press (WebXR Gamepad API)
 if (controller && controller.gamepad) {
 controller.addEventListener('selectstart', () => {
 // Existing selectstart logic if needed
 });
 // Listen for thumbstick press
 controller.addEventListener('thumbstickdown', togglePause); // Custom event, see below
 }
 });
 }
}

// Polyfill for thumbstick press event (since WebXR does not emit 'thumbstickdown' directly)
function setupThumbstickListeners() {
 if (window.app && window.app.sceneManager && window.app.sceneManager.controllers) {
 window.app.sceneManager.controllers.forEach(controller => {
 if (controller && controller.gamepad) {
 let lastThumbstickPressed = false;
 function checkThumbstick() {
 const gp = controller.gamepad;
 if (gp && gp.buttons && gp.buttons.length > 2) {
 const pressed = gp.buttons[3]?.pressed; // Button 3 is usually thumbstick
 if (pressed && !lastThumbstickPressed) {
 // Dispatch custom event
 controller.dispatchEvent({ type: 'thumbstickdown' });
 }
 lastThumbstickPressed = pressed;
 }
 requestAnimationFrame(checkThumbstick);
 }
 checkThumbstick();
 }
 });
 }
}

// Call the setup functions after VR controllers are initialized
setTimeout(() => {
 setupVRNavigation();
 setupThumbstickListeners();
}, 2000); // Delay to ensure controllers are available

// ===========================
// MAIN APPLICATION
// ===========================
class App {
 constructor() {
 this.sceneManager = null;
 this.uiManager = null;
 this.solarSystemModule = null;
 this.lastTime = 0;
 this.timeSpeed = 1; // Default to 1x real-time (original default)
 this.brightness = 100; // Default brightness percentage
 
 // Make this app instance globally accessible for VR and other modules
 window.app = this;
 
 this.init();
 }

 async init() {
 const appStartTime = performance.now();
 
 try {
 // Check cache status
 const cacheReady = await warmupTextureCache();
 if (cacheReady && DEBUG.PERFORMANCE) {
 console.log(' Fast start: All essential textures cached');
 }
 
 // Initialize managers
 this.sceneManager = new SceneManager();
 this.uiManager = new UIManager();
 
 const t = window.t || ((key) => key);
 this.uiManager.showLoading(t('initializing'));
 this.uiManager.updateLoadingProgress(0, t('settingUpScene'));
 
 // Setup global UI functions
 this.setupGlobalFunctions();
 this.uiManager.updateLoadingProgress(10, t('initializingControls'));
 
 // Setup help button
 this.setupHelpButton();
 this.uiManager.updateLoadingProgress(15, t('loadingSolarSystem'));

 // Load Solar System module directly
 const moduleStartTime = performance.now();
 this.solarSystemModule = new SolarSystemModule(this.uiManager);
 this.uiManager.updateLoadingProgress(20, t('creatingSun'));
 
 // The init method now handles its own async loading and will call startExperience() when done
 await this.solarSystemModule.init(this.sceneManager.scene);
 
 if (DEBUG.PERFORMANCE) {
 const totalTime = performance.now() - appStartTime;
 console.log(` Module loaded in ${totalTime.toFixed(0)}ms`);
 }
 } catch (error) {
 console.error(' Failed to initialize Space Voyage:', error);
 this.sceneManager?.showError('Failed to start Space Voyage. Please refresh the page.');
 }
 }
 
 startExperience() {
 // Called by SolarSystemModule after all assets are loaded
 console.log(' Starting experience...');
 
 // Setup UI for Solar System
 this.uiManager.setupSolarSystemUI(this.solarSystemModule, this.sceneManager);
 
 // Setup controls
 this.setupControls();
 
 // Hide loading screen
 this.uiManager.hideLoading();
 
 console.log(' Starting animation loop...');
 console.log(' Sun position:', this.solarSystemModule.sun?.position);
 console.log(' Earth position:', this.solarSystemModule.planets?.earth?.position);
 
 // Start animation loop
 this.sceneManager.animate(() => {
 // Initialize timing on first frame
 if (!this.lastTime) {
 this.lastTime = performance.now();
 return;
 }
 
 const currentTime = performance.now();
 const deltaTime = Math.min((currentTime - this.lastTime) / 1000, CONFIG.PERFORMANCE.maxDeltaTime);
 this.lastTime = currentTime;
 
 // Update XR controller movement and laser pointers
 this.sceneManager.updateXRMovement();
 this.sceneManager.updateLaserPointers();
 
 // Update Solar System module every frame
 if (this.solarSystemModule) {
 this.solarSystemModule.update(deltaTime, this.timeSpeed, 
 this.sceneManager.camera, this.sceneManager.controls);
 }
 });
 
 console.log(` Space Voyage ready!`);
 console.log(` Planets loaded: ${Object.keys(this.solarSystemModule.planets).length}`);
 console.log(` Objects in scene: ${this.solarSystemModule.objects.length}`);
 }

 setupGlobalFunctions() {
 // Close info panel
 window.closeInfoPanel = () => {
 this.uiManager.closeInfoPanel();
 };
 
 // Close help modal
 window.closeHelpModal = () => {
 this.uiManager.closeHelpModal();
 };
 }

 setupHelpButton() {
 const helpButton = document.getElementById('help-button');
 if (helpButton) {
 helpButton.addEventListener('click', () => {
 this.uiManager.showHelp(`
 <h3> Controls</h3>
 <p> <strong>Click & Drag:</strong> Rotate view around selected object</p>
 <p> <strong>Scroll:</strong> Zoom in/out (closer or farther from object)</p>
 <p> <strong>Right Click & Drag:</strong> Pan camera position</p>
 <p> <strong>Click Objects:</strong> Select and focus on object</p>
 <p> <strong>Explorer Panel:</strong> Click object names to jump to them</p>
 
 <h3>âŒ¨ Keyboard Shortcuts</h3>
 <p>âŒ¨ <span class="keyboard-shortcut">H</span> Show this help</p>
 <p>âŒ¨ <span class="keyboard-shortcut">R</span> Reset camera view</p>
 <p>âŒ¨ <span class="keyboard-shortcut">O</span> Toggle orbital paths</p>
 <p>âŒ¨ <span class="keyboard-shortcut">D</span> Toggle object labels</p>
 <p>âŒ¨ <span class="keyboard-shortcut">S</span> Toggle realistic scale</p>
 <p>âŒ¨ <span class="keyboard-shortcut">L</span> Toggle VR laser pointers (in VR)</p>
 <p>âŒ¨ <span class="keyboard-shortcut">F</span> Toggle FPS counter</p>
 <p>âŒ¨ <span class="keyboard-shortcut">+/-</span> Speed up/slow down time</p>
 <p>âŒ¨ <span class="keyboard-shortcut">ESC</span> Close panels</p>
 
 <h3> Object Inspection</h3>
 <p> <strong>After selecting an object:</strong></p>
 <p> - Drag to rotate camera around the object</p>
 <p> - Scroll to zoom in for close-up views</p>
 <p> - View object from all sides and angles</p>
 <p> - Camera stays focused as object moves in orbit</p>
 
 <h3> Settings</h3>
 <p>â± <strong>Speed Slider:</strong> 0x to 10x animation speed</p>
 <p> <strong>Brightness Slider:</strong> Adjust lighting for dark objects</p>
 <p> <strong>Reset Button:</strong> Return camera to starting position</p>
 
 <h3> VR Mode</h3>
 <p> Click "Enter VR" button (bottom right)</p>
 <p> Requires WebXR-compatible VR headset</p>
 <p> <strong>VR Controls:</strong></p>
 <p> - Left stick: Move forward/backward/strafe</p>
 <p> - Right stick: Turn left/right, move up/down</p>
 <p> - Trigger (hold): Sprint mode while moving</p>
 <p> - Grip button: Toggle VR menu (pause, controls, etc.)</p>
 <p> - Point + Trigger: Select planets</p>
 <p> - L key or VR menu: Toggle laser pointers for better immersion</p>
 
 <h3> Tips</h3>
 <p> Increase brightness to see dark sides of planets</p>
 <p> Use speed slider to watch orbits in fast-forward</p>
 <p> Click objects directly or use the explorer panel</p>
 <p> Zoom in close to see surface details and textures</p>
 <p> Rotate around objects to view from all angles</p>
 
 <h3> Performance</h3>
 <p> Optimized for 60 FPS on modern devices</p>
 <p> Adaptive quality for mobile devices</p>
 <p> Hardware-accelerated WebGL rendering</p>
 <p> Press <span class="keyboard-shortcut">F</span> to show FPS counter</p>
 
 <h3> Explore the Solar System!</h3>
 <p> Navigate through our solar system</p>
 <p> Learn about the Sun, planets, moons, and more</p>
 <p> Discover fascinating facts about each celestial body</p>
 `);
 }, { passive: true });
 }
 
 // Setup keyboard shortcuts
 this.setupKeyboardShortcuts();
 
 // Setup FPS counter
 this.setupFPSCounter();
 }
 
 setupControls() {
 // Time speed control is handled by UIManager
 // App.timeSpeed is updated by UIManager's updateSpeed function via window.app
 
 // Orbit toggle button
 const orbitsButton = document.getElementById('toggle-orbits');
 if (orbitsButton) {
 // Set initial state based on default visibility
 if (this.solarSystemModule && this.solarSystemModule.orbitsVisible) {
 orbitsButton.classList.add('toggle-on');
 }
 
 orbitsButton.addEventListener('click', () => {
 if (this.solarSystemModule) {
 const visible = !this.solarSystemModule.orbitsVisible;
 this.solarSystemModule.toggleOrbits(visible);
 orbitsButton.classList.toggle('toggle-on', visible);
 console.log(` Orbits toggled: ${visible ? 'ON' : 'OFF'}`);
 }
 });
 }
 
 // Constellation toggle button
 const constellationsButton = document.getElementById('toggle-constellations');
 if (constellationsButton) {
 // Set initial state based on default visibility
 if (this.solarSystemModule && this.solarSystemModule.constellationsVisible) {
 constellationsButton.classList.add('toggle-on');
 }
 
 constellationsButton.addEventListener('click', () => {
 if (this.solarSystemModule) {
 const visible = !this.solarSystemModule.constellationsVisible;
 this.solarSystemModule.toggleConstellations(visible);
 constellationsButton.classList.toggle('toggle-on', visible);
 console.log(` Constellations toggled: ${visible ? 'ON' : 'OFF'}`);
 }
 });
 }

 // Scale toggle button
 const scaleButton = document.getElementById('toggle-scale');
 if (scaleButton) {
 scaleButton.addEventListener('click', () => {
 if (this.solarSystemModule) {
 const t = window.t || ((key) => key);
 this.solarSystemModule.realisticScale = !this.solarSystemModule.realisticScale;
 scaleButton.classList.toggle('active');
 scaleButton.textContent = this.solarSystemModule.realisticScale ? 
 t('toggleScaleRealistic') : t('toggleScale');
 
 // Recalculate positions with new scale
 this.solarSystemModule.updateScale();
 }
 });
 }
 
 // Labels toggle button
 const labelsButton = document.getElementById('toggle-details');
 if (labelsButton) {
 // Use translation function if available, otherwise fallback to English
 const t = window.t || ((key) => key);
 labelsButton.textContent = t('toggleLabels');
 labelsButton.classList.remove('toggle-on');
 
 labelsButton.addEventListener('click', () => {
 if (this.solarSystemModule && this.solarSystemModule.toggleLabels) {
 if (this.sceneManager) {
 this.sceneManager.labelsVisible = !this.sceneManager.labelsVisible;
 this.solarSystemModule.toggleLabels(this.sceneManager.labelsVisible);
 labelsButton.classList.toggle('toggle-on', this.sceneManager.labelsVisible);
 labelsButton.textContent = this.sceneManager.labelsVisible ? 
 t('toggleLabelsOn') : t('toggleLabels');
 console.log(` Labels toggled: ${this.sceneManager.labelsVisible ? 'ON' : 'OFF'}`);
 }
 }
 });
 }
 
 // Reset view button
 const resetButton = document.getElementById('reset-view');
 if (resetButton) {
 resetButton.addEventListener('click', () => {
 if (this.solarSystemModule) {
 this.solarSystemModule.focusedObject = null;
 }
 this.sceneManager.resetCamera();
 });
 }
 // Canvas click for object selection
 this.sceneManager.renderer.domElement.addEventListener('click', (e) => {
 this.handleCanvasClick(e);
 });
 
 // Navigation dropdown
 const dropdown = document.getElementById('object-dropdown');
 if (dropdown) {
 dropdown.addEventListener('change', (e) => {
 const value = e.target.value;
 if (!value) return; // Ignore the placeholder option
 
 console.log(` Dropdown navigation to: ${value}`);
 
 // Reset dropdown to placeholder
 dropdown.value = '';
 
 // Find and focus on the selected object
 if (this.solarSystemModule) {
 let targetObject = null;
 
 // Map dropdown values to actual objects
 switch(value) {
 case 'sun':
 targetObject = this.solarSystemModule.sun;
 break;
 case 'mercury':
 case 'venus':
 case 'earth':
 case 'mars':
 case 'jupiter':
 case 'saturn':
 case 'uranus':
 case 'neptune':
 targetObject = this.solarSystemModule.planets[value];
 break;
 case 'moon':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Moon');
 break;
 case 'pluto':
 targetObject = this.solarSystemModule.planets.pluto;
 break;
 // Moons
 case 'phobos':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Phobos');
 break;
 case 'deimos':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Deimos');
 break;
 case 'io':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === 'Io');
 break;
 case 'europa':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === 'Europa');
 break;
 case 'ganymede':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === 'Ganymede');
 break;
 case 'callisto':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === 'Callisto');
 break;
 case 'titan':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Titan');
 break;
 case 'enceladus':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Enceladus');
 break;
 case 'rhea':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Rhea');
 break;
 case 'titania':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Titania');
 break;
 case 'miranda':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Miranda');
 break;
 case 'triton':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Triton');
 break;
 case 'charon':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Charon');
 break;
 // Nearby Stars
 case 'alpha-centauri':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Alpha Centauri A');
 break;
 case 'proxima-centauri':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Proxima Centauri');
 break;
 // Exoplanets
 case 'proxima-b':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Proxima Centauri b');
 break;
 case 'kepler-452b':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Kepler-452b');
 break;
 case 'trappist-1e':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' TRAPPIST-1e');
 break;
 case 'kepler-186f':
 targetObject = this.solarSystemModule.objects.find(obj => obj.userData.name === ' Kepler-186f');
 break;
 // Spacecraft & Satellites
 case 'iss':
 targetObject = this.solarSystemModule.satellites?.find(s => s.userData.name.includes('ISS') || s.userData.name.includes('International Space Station'));
 break;
 case 'hubble':
 targetObject = this.solarSystemModule.satellites?.find(s => s.userData.name.includes('Hubble'));
 break;
 case 'voyager-1':
 targetObject = this.solarSystemModule.spacecraft?.find(s => s.userData.name.includes('Voyager 1'));
 break;
 case 'voyager-2':
 targetObject = this.solarSystemModule.spacecraft?.find(s => s.userData.name.includes('Voyager 2'));
 break;
 case 'new-horizons':
 targetObject = this.solarSystemModule.spacecraft?.find(s => s.userData.name.includes('New Horizons'));
 break;
 case 'jwst':
 case 'james-webb':
 targetObject = this.solarSystemModule.spacecraft?.find(s => s.userData.name.includes('James Webb'));
 break;
 case 'juno':
 targetObject = this.solarSystemModule.spacecraft?.find(s => s.userData.name.includes('Juno'));
 break;
 case 'cassini':
 targetObject = this.solarSystemModule.spacecraft?.find(s => s.userData.name.includes('Cassini'));
 break;
 case 'pioneer-10':
 targetObject = this.solarSystemModule.spacecraft?.find(s => s.userData.name.includes('Pioneer 10'));
 break;
 case 'pioneer-11':
 targetObject = this.solarSystemModule.spacecraft?.find(s => s.userData.name.includes('Pioneer 11'));
 break;
 // Nebulae
 case 'orion-nebula':
 targetObject = this.solarSystemModule.nebulae?.find(n => n.userData.name.includes('Orion'));
 break;
 case 'crab-nebula':
 targetObject = this.solarSystemModule.nebulae?.find(n => n.userData.name.includes('Crab'));
 break;
 case 'ring-nebula':
 targetObject = this.solarSystemModule.nebulae?.find(n => n.userData.name.includes('Ring'));
 break;
 // Galaxies
 case 'andromeda-galaxy':
 targetObject = this.solarSystemModule.galaxies?.find(g => g.userData.name.includes('Andromeda'));
 break;
 case 'whirlpool-galaxy':
 targetObject = this.solarSystemModule.galaxies?.find(g => g.userData.name.includes('Whirlpool'));
 break;
 case 'sombrero-galaxy':
 targetObject = this.solarSystemModule.galaxies?.find(g => g.userData.name.includes('Sombrero'));
 break;
 // Constellations - Zodiac
 case 'constellation-aries':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Aries'));
 break;
 case 'constellation-taurus':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Taurus'));
 break;
 case 'constellation-gemini':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Gemini'));
 if (DEBUG.enabled) console.log(` [Nav Debug] Gemini search result:`, targetObject ? targetObject.userData.name : 'NOT FOUND', `(total constellations: ${this.solarSystemModule.constellations?.length || 0})`);
 break;
 case 'constellation-cancer':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Cancer'));
 break;
 case 'constellation-leo':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Leo'));
 break;
 case 'constellation-virgo':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Virgo'));
 break;
 case 'constellation-libra':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Libra'));
 break;
 case 'constellation-scorpius':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Scorpius'));
 if (DEBUG.enabled) console.log(` [Nav Debug] Scorpius search result:`, targetObject ? targetObject.userData.name : 'NOT FOUND', `(total constellations: ${this.solarSystemModule.constellations?.length || 0})`);
 break;
 case 'constellation-sagittarius':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Sagittarius'));
 break;
 case 'constellation-capricornus':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Capricornus'));
 break;
 case 'constellation-aquarius':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Aquarius'));
 break;
 case 'constellation-pisces':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Pisces'));
 break;
 // Constellations - Other
 case 'constellation-orion':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Orion'));
 break;
 case 'constellation-big-dipper':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Big Dipper') || c.userData.name.includes('Ursa Major'));
 break;
 case 'constellation-little-dipper':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Little Dipper') || c.userData.name.includes('Ursa Minor'));
 break;
 case 'constellation-southern-cross':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Southern Cross') || c.userData.name.includes('Crux'));
 break;
 case 'constellation-cassiopeia':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Cassiopeia'));
 break;
 case 'constellation-cygnus':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Cygnus'));
 break;
 case 'constellation-lyra':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Lyra'));
 break;
 case 'constellation-andromeda':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Andromeda') && c.userData.name.includes('Princess'));
 break;
 case 'constellation-perseus':
 targetObject = this.solarSystemModule.constellations?.find(c => c.userData.name.includes('Perseus'));
 break;
 default:
 console.warn(` [Nav] âœ— No case match for value: "${value}"`);
 break;
 }
 
 console.log(` [Nav] Navigation dropdown value: "${value}"`);
 console.log(` [Nav] After switch - targetObject:`, targetObject ? `Found: ${targetObject.userData?.name}` : 'NULL');
 
 if (targetObject) {
 const info = this.solarSystemModule.getObjectInfo(targetObject);
 this.uiManager.updateInfoPanel(info);
 console.log(` [Nav] âœ“ Found and navigating to: ${info.name} (type: ${targetObject.userData.type || 'planet'})`);
 this.solarSystemModule.focusOnObject(targetObject, this.sceneManager.camera, this.sceneManager.controls);
 } else {
 console.warn(` [Nav] âœ— Object not found for value: "${value}"`);
 console.warn(` [Nav] Available constellations:`, this.solarSystemModule.constellations?.map(c => c.userData.name) || []);
 }
 }
 });
 }
 }
 
 handleCanvasClick(event) {
 console.log(' Canvas clicked!');
 if (!this.solarSystemModule) {
 console.warn(' No solar system module!');
 return;
 }
 
 console.log(` Checking ${this.solarSystemModule.objects.length} objects for intersection...`);
 
 const rect = this.sceneManager.renderer.domElement.getBoundingClientRect();
 const mouse = new THREE.Vector2(
 ((event.clientX - rect.left) / rect.width) * 2 - 1,
 -((event.clientY - rect.top) / rect.height) * 2 + 1
 );

 this.sceneManager.raycaster.setFromCamera(mouse, this.sceneManager.camera);
 const intersects = this.sceneManager.raycaster.intersectObjects(this.solarSystemModule.objects, true);

 console.log(` Found ${intersects.length} intersections`);
 if (intersects.length > 0) {
 let target = intersects[0].object;
 while (target.parent && !target.userData.name) {
 target = target.parent;
 }

 if (target.userData && target.userData.name) {
 const info = this.solarSystemModule.getObjectInfo(target);
 this.uiManager.updateInfoPanel(info);
 this.solarSystemModule.focusOnObject(target, this.sceneManager.camera, this.sceneManager.controls);
 }
 }
 }
 
 setupKeyboardShortcuts() {
 document.addEventListener('keydown', (e) => {
 // Ignore if typing in input
 if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
 
 switch(e.key.toLowerCase()) {
 case 'h':
 document.getElementById('help-button')?.click();
 break;
 case 'r':
 document.getElementById('reset-view')?.click();
 break;
 case 'o':
 document.getElementById('toggle-orbits')?.click();
 break;
 case 'd':
 document.getElementById('toggle-details')?.click();
 break;
 case 's':
 document.getElementById('toggle-scale')?.click();
 break;
 case 'f':
 const fpsCounter = document.getElementById('fps-counter');
 if (fpsCounter) {
 fpsCounter.classList.toggle('hidden');
 }
 break;
 case 'l':
 // Toggle VR laser pointers (only works in VR)
 if (this.sceneManager.renderer.xr.isPresenting) {
 this.sceneManager.lasersVisible = !this.sceneManager.lasersVisible;
 this.sceneManager.controllers.forEach(controller => {
 const laser = controller.getObjectByName('laser');
 const pointer = controller.getObjectByName('pointer');
 if (laser) laser.visible = this.sceneManager.lasersVisible;
 if (pointer) pointer.visible = this.sceneManager.lasersVisible;
 });
 console.log(` Laser pointers ${this.sceneManager.lasersVisible ? 'visible' : 'hidden'}`);
 }
 break;
 case '+':
 case '=':
 // Increase speed
 const speedSliderUp = document.getElementById('time-speed');
 if (speedSliderUp) {
 const currentValue = parseFloat(speedSliderUp.value);
 const newValue = Math.min(10, currentValue + 0.5);
 speedSliderUp.value = newValue;
 speedSliderUp.dispatchEvent(new Event('input'));
 }
 break;
 case '-':
 case '_':
 // Decrease speed
 const speedSliderDown = document.getElementById('time-speed');
 if (speedSliderDown) {
 const currentValue = parseFloat(speedSliderDown.value);
 const newValue = Math.max(0, currentValue - 0.5);
 speedSliderDown.value = newValue;
 speedSliderDown.dispatchEvent(new Event('input'));
 }
 break;
 case 'escape':
 this.uiManager.closeInfoPanel();
 this.uiManager.closeHelpModal();
 break;
 case ' ':
 case 'space':
 // SPACE = Toggle between Paused and Normal speed
 e.preventDefault();
 const spaceSpeedSlider = document.getElementById('time-speed');
 if (spaceSpeedSlider) {
 if (this.timeSpeed === 0) {
 // If paused, go to normal (5 = 1x speed)
 spaceSpeedSlider.value = '5';
 console.log(' PLAY (Normal Speed)');
 } else {
 // If playing, pause
 spaceSpeedSlider.value = '0';
 console.log('â¸ PAUSE');
 }
 spaceSpeedSlider.dispatchEvent(new Event('input'));
 }
 break;
 case 'i':
 // Find and focus on ISS
 if (this.solarSystemModule?.spacecraft) {
 const iss = this.solarSystemModule.spacecraft.find(s => s.userData.name.includes('ISS'));
 if (iss) {
 this.solarSystemModule.focusOnObject(iss, this.sceneManager.camera, this.sceneManager.controls);
 console.log(' Focusing on International Space Station');
 }
 }
 break;
 case 'v':
 // Cycle through Voyager probes
 if (this.solarSystemModule?.spacecraft) {
 const voyagers = this.solarSystemModule.spacecraft.filter(s => s.userData.name.includes('Voyager'));
 if (voyagers.length > 0) {
 this._voyagerIndex = ((this._voyagerIndex || 0) + 1) % voyagers.length;
 this.solarSystemModule.focusOnObject(voyagers[this._voyagerIndex], this.sceneManager.camera, this.sceneManager.controls);
 console.log(` Focusing on ${voyagers[this._voyagerIndex].userData.name}`);
 }
 }
 break;
 case 'm':
 // Cycle through Mars rovers
 if (this.solarSystemModule?.spacecraft) {
 const rovers = this.solarSystemModule.spacecraft.filter(s => s.userData.type === 'rover');
 if (rovers.length > 0) {
 this._roverIndex = ((this._roverIndex || 0) + 1) % rovers.length;
 this.solarSystemModule.focusOnObject(rovers[this._roverIndex], this.sceneManager.camera, this.sceneManager.controls);
 console.log(` Focusing on ${rovers[this._roverIndex].userData.name}`);
 }
 }
 break;
 case 'p':
 // Cycle through deep space probes
 if (this.spacecraft) {
 const probes = this.spacecraft.filter(s => s.userData.type === 'probe');
 if (probes.length > 0) {
 this._probeIndex = ((this._probeIndex || 0) + 1) % probes.length;
 this.focusOnObject(probes[this._probeIndex], this.camera, this.controls);
 console.log(`??? Focusing on ${probes[this._probeIndex].userData.name}`);
 }
 }
 break;
 }
 }, { passive: true });
 }
 
 setupFPSCounter() {
 let frameCount = 0;
 let lastTime = performance.now();
 const fpsValue = document.getElementById('fps-value');
 const fpsCounter = document.getElementById('fps-counter');
 
 const updateFPS = () => {
 frameCount++;
 const currentTime = performance.now();
 
 if (currentTime >= lastTime + 1000) {
 const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
 if (fpsValue) {
 fpsValue.textContent = fps;
 }
 
 // Update color based on FPS
 if (fpsCounter) {
 fpsCounter.classList.remove('good', 'warning', 'bad');
 if (fps >= 55) {
 fpsCounter.classList.add('good');
 } else if (fps >= 30) {
 fpsCounter.classList.add('warning');
 } else {
 fpsCounter.classList.add('bad');
 }
 }
 
 frameCount = 0;
 lastTime = currentTime;
 }
 
 requestAnimationFrame(updateFPS);
 };
 
 updateFPS();
 }
}

// Start the application when DOM is ready
if (document.readyState === 'loading') {
 document.addEventListener('DOMContentLoaded', () => new App());
} else {
 new App();
}



